/**
 * Program using the FDTD-Method in two dimensions in the TEz mode.
 * The goal is to simulate electromagnetic waves in a disc inside a perfect
 * electric conductor (PEC) or perfect magnetic conductor (PMC) to create
 * so-called whispering gallery modes.
 *
 * The E-field and the H-field are updated alternating using two different
 * stencils.
 *
 * All values are in SI units.
 *
 * Author: Max Nolte (nolte.max@sms.ed.ac.uk)
 * with help by Matthias Christen
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

#include "WhisperingGallery.h"

// These files contain the forward declarations to the Patus-generated
// functions and are automatically generated in the Makefile
#include "fdtdE2D.h"
#include "fdtdH2D.h"
#include "integrate.h"


// Size of the simulation
// IMPORTANT: Needs to be divisible by 8
#define GRID_SIZE 1000

// The grid is stored in an one-dimensional array;
// function to calculate position
#define POS(i,j) ((i)+((x_max)*(j)))


// 
// Simulation-specific constants
//

// Permittivity of free space (electric constant)
#define EPSILON 8.854187817e-12f

// Permeability of free space (magnetic constant)
#define MU 1.25663706e-6f

// Speed of light in vacuum
#define C0 299792458.0f

// Wave length (500nm)
#define LAMBDA (GRID_SIZE * 5e-9f)

// Angular frequency of gaussian source
#define OMEGA (2.0f * M_PI * C0 / LAMBDA)

// Time-step: DT = LAMBDA/(20*C0*sqrt(2))
// This is due to the magic time step DT*C0*sqrt(2) = DX of the FDTD method.
#define DT 5.896635842e-17f

// Total time of simulation T = DT*T_MAX = 295 femtoseconds
#define T_MAX 5000


int main()
{
	int t, i, j, k;

	// Define the size of the grids (use quadratic grids)
	int x_max = GRID_SIZE;
	int y_max = GRID_SIZE;

	// Grids to store the E-field (two components) and the H-field (one
	// component) for t and t+1
	float *_e_0_0, *e_0_0;
	float *_e_1_0, *e_1_0;
	float *_e_0_1, *e_0_1;
	float *_e_1_1, *e_1_1;
	float *_h_2_0, *h_2_0;
	float *_h_2_1, *h_2_1;

	// Grids with the constants defining the material
	float *_ca, *ca;
	float *_cb, *cb;
	float *_da, *da;
	float *_db, *db;

	// Output grid for the averaged electromagnetic energy
	float *_u_em, *u_em;


	// Allocate memory
	allocate(&_e_0_0, &e_0_0, x_max, y_max);
	allocate(&_e_1_0, &e_1_0, x_max, y_max);
	allocate(&_e_0_1, &e_0_1, x_max, y_max);
	allocate(&_e_1_1, &e_1_1, x_max, y_max);
	allocate(&_h_2_0, &h_2_0, x_max, y_max);
	allocate(&_h_2_1, &h_2_1, x_max, y_max);
	
	allocate(&_ca, &ca, x_max, y_max);
	allocate(&_cb, &cb, x_max, y_max);
	allocate(&_da, &da, x_max, y_max);
	allocate(&_db, &db, x_max, y_max);
	
	allocate(&_u_em, &u_em, x_max, y_max);
	

	// Initialize
	float ca_vacuum = calculateCa(0.0f, 1.0f);
	float cb_vacuum = calculateCb(0.0f, 1.0f);
	float da_vacuum = calculateDa(0.0f, 1.0f);
	float db_vacuum = calculateDb(0.0f, 1.0f);
	
	// Choose one of PMC or PEC

	// Material properties for PMC 
	// magnetic field in the conductor is always 0)
	float ca_material = calculateCa(0.0f, 1.0f);
	float cb_material = calculateCb(0.0f, 1.0f);
	float da_material = 0.0f;
	float db_material = 0.0f;

	/*	
	// Material properties for PEC
	// (electric field in the conductor is always 0)
	float ca_material = 0.0f;
	float cb_material = 0.0f;
	float da_material = calculateDa(0.0f, 1.0f);
	float db_material = calculateDb(0.0f, 1.0f);
	*/

	// Call initialization functions generated by Patus
	initialize_fdtdE2D(e_0_0, e_1_0, e_0_1, e_1_1, h_2_0, ca, cb,
		ca_vacuum, ca_material, cb_vacuum, cb_material, x_max, y_max);
	initialize_fdtdH2D(e_0_0, e_1_0, h_2_0, h_2_1, da, db,
		da_vacuum, da_material, db_vacuum, db_material, x_max, y_max);
	initialize_integrate(e_0_0, e_1_0, h_2_0, u_em, u_em,
		MU, EPSILON, x_max, y_max);
	

	// Pointers to output, not actually needed
	float* dummy = NULL;

	// Simulation loop
	// Call Patus-generated kernels
	double fTimeStart = gettime ();	
	#pragma omp parallel private (t)
	{
		for (t = 0; t < T_MAX; t++)
		{
			fdtdE2D (&dummy, &dummy, e_0_0, e_1_0, e_0_1, e_1_1, h_2_0,
				ca, cb, ca_vacuum, ca_material, cb_vacuum, cb_material,
				x_max, y_max
			);
			#pragma omp barrier
		
			#pragma omp single
			{
				// Rotate grid pointers (need to do this manually since
				// we compute only one timestep in the generated functions)
				float* temp0 = e_0_0;
				e_0_0 = e_0_1;
				e_0_1 = temp0;
				float* temp1 = e_1_0;
				e_1_0 = e_1_1;
				e_1_1 = temp1;
			}

			fdtdH2D (&dummy, e_0_0, e_1_0, h_2_0, h_2_1, da, db,
				da_vacuum, da_material, db_vacuum, db_material, x_max, y_max
			);
			#pragma omp barrier

			#pragma omp single
			{
				// Rotate grid pointers
				float* temp2 = h_2_0;
				h_2_0 = h_2_1;
				h_2_1 = temp2;

				// Adding the source, needs to lie in vacuum disk
				h_2_0[POS((int) (GRID_SIZE * 0.5), (int) (GRID_SIZE * 0.3))] +=
					gaussianSource(t*DT);
			}

			// Accumulate the energy density
			if (t > 4000)
			{
				integrate (&dummy, e_0_0, e_1_0, h_2_0, u_em, u_em,
					MU, EPSILON, x_max, y_max
				);
				#pragma omp barrier
			}
		}
	}

	double fTimeEnd = gettime();
	printf("Time used: %f s\n", fTimeEnd - fTimeStart);
	
	// Write the output to a file
	write(u_em, x_max, y_max);
	
	// Clean up
	free (_e_0_0);
	free (_e_1_0);
	free (_e_0_1);
	free (_e_1_1);
	free (_h_2_0);
	free (_h_2_1);
	free (_u_em);

	free (_ca);
	free (_cb);
	free (_da);
	free (_db);
	
	return 0;
}

/**
 * The Gaussian, additive wave source.
 */
float gaussianSource(float t)
{
	// Time of maximum excitation
	const float T0 = 2.95e-14f;
	
	// "Size" of impulse wave
	const float D = 1.5e32f / (GRID_SIZE * GRID_SIZE);
	
	return expf(-(t - T0) * (t - T0) / D) * cosf((t - T0) * OMEGA);
}

//
// Functions to calculate the constants that depend on the material properties
//

/**
 * sigma: electric conductivity
 * er:    relative (electric) permittivity of material
 */
float calculateCa(float sigma, float er)
{
	return (1.0f - sigma * DT / (2.0f * EPSILON * er)) /
		(1.0f + sigma * DT / (2.0f * EPSILON * er));
}

/**
 * sigma: electric conductivity
 * er:    relative (electric) permittivity of material
 */
float calculateCb(float sigma, float er)
{
	return (1.0f / (EPSILON * er * C0 * sqrtf(2.0f))) /
		(1.0f + sigma * DT / (2.0f * EPSILON * er));
}

/**
 * sigma: equivalent magnetic conductivity
 * mur:   (magnetic) permeability of material
 */
float calculateDa(float sigma, float mur)
{
	return (1.0f - sigma * DT / (2.0f * MU * mur)) /
		(1.0f + sigma * DT / (2.0f * MU * mur));
}

/**
 * sigma: equivalent magnetic conductivity
 * mur:  (magnetic) permeability of material
 */
float calculateDb(float sigma, float mur)
{
	return (1.0f / (MU * mur * C0 * sqrtf(2.0f))) /
		(1.0f + sigma * DT / (2.0f * MU * mur));
}

