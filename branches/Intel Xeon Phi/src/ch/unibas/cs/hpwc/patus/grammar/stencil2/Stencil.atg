/*******************************************************************************
 * Copyright (c) 2011 Matthias-M. Christen, University of Basel, Switzerland.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * 
 * Contributors:
 *     Matthias-M. Christen, University of Basel, Switzerland - initial API and implementation
 ******************************************************************************/
///////////////////////////////////////////////////////////////////////////
// Imports

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import cetus.hir.ArrayAccess;
import cetus.hir.AssignmentExpression;
import cetus.hir.AssignmentOperator;
import cetus.hir.BinaryExpression;
import cetus.hir.BinaryOperator;
import cetus.hir.DepthFirstIterator;
import cetus.hir.Expression;
import cetus.hir.FloatLiteral;
import cetus.hir.FunctionCall;
import cetus.hir.IDExpression;
import cetus.hir.IntegerLiteral;
import cetus.hir.Literal;
import cetus.hir.NameID;
import cetus.hir.Specifier;
import cetus.hir.UnaryExpression;
import cetus.hir.UnaryOperator;

import ch.unibas.cs.hpwc.patus.codegen.CodeGenerationOptions;
import ch.unibas.cs.hpwc.patus.codegen.Globals;
import ch.unibas.cs.hpwc.patus.geometry.Box;
import ch.unibas.cs.hpwc.patus.geometry.Point;
import ch.unibas.cs.hpwc.patus.representation.Index;
import ch.unibas.cs.hpwc.patus.representation.Stencil;
import ch.unibas.cs.hpwc.patus.representation.StencilBundle;
import ch.unibas.cs.hpwc.patus.representation.StencilCalculation;
import ch.unibas.cs.hpwc.patus.representation.StencilNode;
import ch.unibas.cs.hpwc.patus.symbolic.ExpressionData;
import ch.unibas.cs.hpwc.patus.symbolic.Symbolic;
import ch.unibas.cs.hpwc.patus.util.CodeGeneratorUtil;
import ch.unibas.cs.hpwc.patus.util.DomainPointEnumerator;
import ch.unibas.cs.hpwc.patus.util.ExpressionUtil;
import ch.unibas.cs.hpwc.patus.util.IntArray;
import ch.unibas.cs.hpwc.patus.util.StringUtil;


COMPILER StencilSpecification

	///////////////////////////////////////////////////////////////////////////
	// Inner Types
	
	/**
	 * Specifies whether a stream (i.e. a stencil node) is an input or
	 * an output node.
	 */
	enum EStreamDirection
	{
		/**
		 * A stream from which data is read
		 */
		INPUT,
		
		/**
		 * A stream to which data is written to
		 */
		OUTPUT
	}
	
	/**
	 * Helper class for mapping multidimensional and differently named identifiers
	 * to a normalized set of identifiers (map to vector components of StencilNodes).
	 */
	protected class StreamIndex
	{
		private Specifier m_specType;
		private boolean m_bIsConstant;
		private Box m_boxStreamDimensions;
		private int m_nStartIndex;
		private Range[] m_rgDimensions;
		
		/**
		 * Constructs a new stream index.
		 */
		public StreamIndex (String strName, Specifier specType, boolean bIsConstant, Box boxDimensions, List<Range> listDimensions, EStreamDirection sd)
		{
			m_specType = specType;
			m_bIsConstant = bIsConstant;
			m_boxStreamDimensions = boxDimensions;
			
			// copy the dimensions
			m_rgDimensions = new Range[listDimensions.size ()];
			int i = 0;
			for (Range range : listDimensions)
				m_rgDimensions[i++] = range;
			
			// calculate the total number of dimensions
			int nStreamsCount = 1;
			for (Range range : listDimensions)
				nStreamsCount *= range.getSize ();

			// set the start index and the new number of total streams
			StreamIndex idx = m_mapInputStreams.get (strName);
			if (idx == null)
				idx = m_mapOutputStreams.get (strName);
			if (idx != null)
				m_nStartIndex = idx.m_nStartIndex;
			else
			{
				m_nStartIndex = m_nTotalStreamsCount;
				m_nTotalStreamsCount += nStreamsCount;
			}
		}
		
		/**
		 * Returns the index.
		 */
		public int getLinearIndex (String strIdentifier, List<Expression> listIndices)
		{
			if ((listIndices == null && m_rgDimensions.length != 0) || (listIndices != null && listIndices.size () != m_rgDimensions.length))
			{
				errors.SemErr (la.line, la.col, StringUtil.concat ("Parameter dimension of ", strIdentifier,
					" does not agree with its definition: should be ", (listIndices == null ? 0 : listIndices.size ()), ".")
				);
				return -1;
			}
			
			int nIdx = 0;
			if (listIndices != null)
			{
				int i = 0;
				for (Expression exprIdxValue : listIndices)
				{
					Integer nIdxValue = ExpressionUtil.getIntegerValueEx (exprIdxValue);
					if (nIdxValue == null)
					{
						errors.SemErr (la.line, la.col, StringUtil.concat ("Value ", exprIdxValue.toString (), " does not evaluate to an integer number"));
						continue;
					}
					
					// check whether the indices are within the defined bounds
					if (nIdxValue < m_rgDimensions[i].getStart () || nIdxValue > m_rgDimensions[i].getEnd ())
					{
						errors.SemErr (la.line, la.col, StringUtil.concat ("Index in dimension ", i, " of \"", strIdentifier, listIndices.toString (), "\" out of bounds: should be in ", m_rgDimensions[i].toString (), "."));
						return -1;
					}
					
					// caluclate index
					nIdx = nIdx * m_rgDimensions[i].getSize () + nIdxValue;
					i++;
				}
			}
						
			return nIdx + m_nStartIndex;
		}
		
		/**
		 * Returns the grid type.
		 */
		public Specifier getSpecifier ()
		{
			return m_specType;
		}
		
		/**
		 * Returns <code>true</code> iff the grid is specified to be a constant grid, i.e. does not change in time.
		 */
		public boolean isConstant ()
		{
			return m_bIsConstant;
		}
		
		/**
		 * Returns the box, i.e., the dimensions of the stream in each direction.
		 */
		public Box getStreamDimensions ()
		{
            return m_boxStreamDimensions;
		}
	}
	
	
	///////////////////////////////////////////////////////////////////////////
	// Member Variables

	/**
	 * The result of the parser
	 */
	private StencilCalculation m_stencil;
	
	private ArithmeticUtil m_au;
	
	/**
	 * The data streams from which data are read
	 */
	private Map<String, StreamIndex> m_mapInputStreams;
	
	/**
	 * The data streams to which data are written
	 */
	private Map<String, StreamIndex> m_mapOutputStreams;
	
	/**
	 * Scalars: Parameters passed to the stencil operation or temporary variables defined
	 * within the stencil operation
	 */
	private Map<String, StencilCalculation.ParamType> m_mapScalars;
	
	/**
	 * Constants: variables that are assigned a constant value within the stencil operation
	 */
	private Map<String, Literal> m_mapConstants;
	
	/**
	 * List of arguments to the stencil operation (in the original order)
	 */
	private List<String> m_listStencilOperationArguments;
	
	/**
	 * A list of size parameters to the stencil definition (contained in the
	 * domain size definition and the optional size parameters to the grids)
	 */
	private List<NameID> m_listSizeParameters;
	
	/**
	 * The current total number of registered streams
	 */
	private int m_nTotalStreamsCount = 0;

	/**
	 * Has <code>t_max</code> been set?
	 */
	private boolean m_bIterateWhileSet = false;
	
	private CodeGenerationOptions m_options;

		
	///////////////////////////////////////////////////////////////////////////
	// Custom Implementation
	
	public void setOptions (CodeGenerationOptions options)
	{
		m_options = options;
		m_au = new ArithmeticUtil (m_options, errors);
	}
	
	public boolean hasErrors ()
	{
		return errors.count > 0;
	}
	
	/**
	 * Returns the stencil calculation object.
	 */
	public StencilCalculation getStencilCalculation ()
	{
		return m_stencil;
	}	
	
	/**
	 * Registers a stream along with its dimensions mapping it to the normalized internal representation.
	 * @param strIdentifier The identifier by which the stream is referred to in the source code
	 * @param box The dimensions of the stream box
	 * @param listDimensions List of dimensions of the stream
	 * @param sd The stream direction specifying whether this is an input or an output stream, i.e. is read from or written to
	 */
	private void registerStream (String strIdentifier, Specifier specType, boolean bIsConstant, Box box, List<Range> listDimensions, EStreamDirection sd)
	{
		// lazily create the maps
		if (m_mapInputStreams == null)
			m_mapInputStreams = new HashMap<> ();
		if (m_mapOutputStreams == null)
			m_mapOutputStreams = new HashMap<> ();
		if (m_listStencilOperationArguments == null)
			m_listStencilOperationArguments = new ArrayList<> ();
		
		if (CodeGeneratorUtil.isDimensionIdentifier (strIdentifier))
		{
			errors.SemErr (StringUtil.concat ("The identifier \"", strIdentifier, "\" represents a dimension and cannot be used as a grid identifier."));
			return;
		}
		
		Map<String, StreamIndex> map = sd == EStreamDirection.INPUT ? m_mapInputStreams : m_mapOutputStreams;
		if (!map.containsKey (strIdentifier))
			map.put (strIdentifier, new StreamIndex (strIdentifier, specType, bIsConstant, box, listDimensions, sd));
		else
			errors.SemErr (la.line, la.col, StringUtil.concat ("Duplicate declaration of grid \"", strIdentifier, "\""));
			
		if (sd == EStreamDirection.INPUT)
			m_listStencilOperationArguments.add (strIdentifier);
	}
			
	private void registerScalar (String strIdentifier, Specifier specType, List<Range> listDimensions, boolean bIsStencilArgument)
	{
		ensureScalarsMapCreated ();
		if (m_listStencilOperationArguments == null)
			m_listStencilOperationArguments = new ArrayList<> ();
			
		if (CodeGeneratorUtil.isDimensionIdentifier (strIdentifier))
		{
			errors.SemErr (StringUtil.concat ("The identifier \"", strIdentifier, "\" represents a dimension and cannot be used as a scalar identifier."));
			return;
		}

		if (!m_mapScalars.containsKey (strIdentifier))
		{
			m_mapScalars.put (strIdentifier, new StencilCalculation.ParamType (specType, listDimensions));
			
			DomainPointEnumerator dpe = new DomainPointEnumerator ();
			for (Range range : listDimensions)
				dpe.addDimension (new DomainPointEnumerator.MinMax (range.getStart (), range.getEnd ()));
				
			if (dpe.size () == 0)
			{
				if (bIsStencilArgument)
					m_listStencilOperationArguments.add (strIdentifier);
			}
			else
			{
				// convert multi-dimensional scalars to simple scalars with the index in their name
				for (int[] rgIdx : dpe)
				{
					String strIndexedIdentifier = m_au.getIndexedIdentifier (strIdentifier, rgIdx);
					m_mapScalars.put (strIndexedIdentifier, new StencilCalculation.ParamType (specType));
					if (bIsStencilArgument)
						m_listStencilOperationArguments.add (strIndexedIdentifier);
				}
			}
		}
	}
	
	private ExpressionData registerScalarAssignment (Stencil stencil, String strIdentifier, ExpressionData edRHS, Specifier specType)
	{
		Expression exprRHS = edRHS.getExpression ();
		Expression exprSimplified = null;
		if (exprRHS instanceof FloatLiteral)
			exprSimplified = exprRHS;
		else if (!containsStencilNode (exprRHS))
			exprSimplified = Symbolic.simplify (exprRHS);
			
		if (exprSimplified instanceof FloatLiteral || exprSimplified instanceof IntegerLiteral)
		{
			registerConstant (strIdentifier, (Literal) exprSimplified);
			return null;
		}

		registerScalar (strIdentifier, specType, new ArrayList<Range> (), false);
		StencilNode node = new StencilNode (strIdentifier, specType, null);
		stencil.addOutputNode (node);
		
		return new ExpressionData (
			new AssignmentExpression (node, AssignmentOperator.NORMAL, exprRHS),
			edRHS.getFlopsCount (),
			Symbolic.EExpressionType.EXPRESSION
		);
	}
	
	private void setParamDefaultValues (String strIdentifier, Map<IntArray, Stencil> mapDefaultValues)
	{
		for (IntArray arrIdx : mapDefaultValues.keySet ())
		{
			String strIndexedIdentifier = m_au.getIndexedIdentifier (strIdentifier, arrIdx.get ());
			StencilCalculation.ParamType pt = m_mapScalars.get (strIndexedIdentifier);
			
			if (pt == null)
				errors.SemErr (StringUtil.concat ("The stencil parameter ", strIndexedIdentifier, " has not yet been registered."));
			else
				pt.setDefaultValue (mapDefaultValues.get (arrIdx).getExpression ());
		}
	}
	
	private void setScalarInitValues (StencilBundle bundle, Specifier specType, String strIdentifier, Map<IntArray, Stencil> mapInit, boolean bOffsetInSpace)
	{
		for (IntArray arrIdx : mapInit.keySet ())
		{
			Stencil stencil = mapInit.get (arrIdx);
			String strIndexedIdentifier = m_au.getIndexedIdentifier (strIdentifier, arrIdx.get ());
			
			ExpressionData edSimplified = registerScalarAssignment (stencil, strIndexedIdentifier, stencil.getExpressionData (), specType);
			if (edSimplified != null)
				stencil.setExpression (edSimplified);
			
			try
			{
				if (!stencil.isEmpty ())
					bundle.addStencil (stencil, bOffsetInSpace);
			}
			catch (NoSuchMethodException e)
			{
				e.printStackTrace ();
			}
		}	
	}
	
	private void registerConstant (String strIdentifier, Literal litValue)
	{
		if (m_mapConstants == null)
			m_mapConstants = new HashMap<> ();
	       
		if (CodeGeneratorUtil.isDimensionIdentifier (strIdentifier))
		{
			errors.SemErr (StringUtil.concat ("The identifier \"", strIdentifier, "\" represents a dimension and cannot be used as a constant identifier."));
			return;
		}
	       
		m_mapConstants.put (strIdentifier, litValue.clone ());
	}
	
	private Literal getConstantValue (String strIdentifier)
	{
		return m_au.getConstantValue (strIdentifier, m_mapConstants);
	}
	
	/**
	 * Returns the internal stream index given the identifier in the source code and indices.
	 * @param strIdentifier The identifier in the source code
	 * @param listIndices A list of indices (subscripts)
	 * @param sd The stream direction specifying whether this is an input or an output stream, i.e. is read from or written to
	 * @return The internal stream index
	 */
	private int getStreamIndex (String strIdentifier, List<Expression> listIndices, EStreamDirection sd)
	{
		Map<String, StreamIndex> map = sd == EStreamDirection.INPUT ? m_mapInputStreams : m_mapOutputStreams;
		StreamIndex idx = map.get (strIdentifier);
		
		if (idx != null)
			return idx.getLinearIndex (strIdentifier, listIndices);
			
		errors.SemErr (la.line, la.col, StringUtil.concat ("The variable \"", strIdentifier, "\" has not been defined"));
		return -1;		
	}
	
	private StreamIndex getInputStream (String strIdentifier)
	{
		StreamIndex si = m_mapInputStreams.get (strIdentifier);
		if (si == null)
			errors.SemErr (la.line, la.col, StringUtil.concat ("The grid \"", strIdentifier, "\" has not been defined"));
		return si;
	}
	
	private StreamIndex getOutputStream (String strIdentifier)
	{
		StreamIndex si = m_mapOutputStreams.get (strIdentifier);
		if (si == null)
		{
			if (m_mapInputStreams.containsKey (strIdentifier))
				errors.SemErr (la.line, la.col, StringUtil.concat ("In order to assign a value to the grid \"", strIdentifier, "\", it must not be declared as \"const\""));
			else
				errors.SemErr (la.line, la.col, StringUtil.concat ("The grid \"", strIdentifier, "\" has not been defined"));
		}
		
		return si;
	}
	
	private StreamIndex getStream (String strIdentifier, EStreamDirection dir)
	{
		return dir == EStreamDirection.INPUT ? getInputStream (strIdentifier) : getOutputStream (strIdentifier);
	}
	
	private void ensureScalarsMapCreated ()
	{
		if (m_mapScalars == null)
		{
			m_mapScalars = new HashMap<> ();
		
			// add constants
			m_mapScalars.put ("PI", new StencilCalculation.ParamType (Specifier.DOUBLE));
		} 
	}
	
	private void checkParameterIndices (String strIdentifier, Expression exprParam, LocalVars lv)
	{
		ensureScalarsMapCreated ();
		StencilCalculation.ParamType param = m_mapScalars.get (strIdentifier);
		if (param == null)
		{
			// the key hasn't been found => parameter is not defined
			// check whether it is a built-in dimension identifier
			if ("t".equals (strIdentifier))
				return;
			if (CodeGeneratorUtil.getDimensionFromName (strIdentifier) >= 0)
				return;	// error if getDimensionFromName returns -1
			
			errors.SemErr (la.line, la.col, StringUtil.concat ("The parameter \"", strIdentifier, "\" has not been defined"));
			return;
		}
		
		// check bounds
		if (exprParam instanceof ArrayAccess)
		{
			ArrayAccess arr = (ArrayAccess) exprParam;
			
			// check whether the dimensions agree
			if (param.getDimensionsCount () != arr.getNumIndices ())
			{
				errors.SemErr (la.line, la.col, StringUtil.concat ("The parameter dimension of ", strIdentifier, " does not agree with its definition: should be ", param.getDimensionsCount (), ", but is ", arr.getNumIndices (), "."));
				return;
			}
			
			// check bounds
			int i = 0;
			for (Range range : param.getRanges ())
			{
				Integer nIdx = ExpressionUtil.getIntegerValueEx (arr.getIndex (i));
				if (nIdx != null)
				{
					if (nIdx < range.getStart () || nIdx > range.getEnd ())
					{
						errors.SemErr (la.line, la.col, StringUtil.concat ("Index in dimension ", i, " of \"", exprParam.toString (), "\" out of bounds: should be in ", range.toString (), "."));
						return;
					}
				}
				else
				{
					// check whether all indices are local variables
					for (DepthFirstIterator it = new DepthFirstIterator (arr.getIndex (i)); it.hasNext (); )
					{
						Object o = it.next ();
						if (o instanceof IDExpression)
						{
							String strName = ((IDExpression) o).getName ();
							if (!lv.hasVariable (strName))
							{
								errors.SemErr (la.line, la.col, StringUtil.concat ("The index \"", strName, "\" has not been declared."));
								return;
							}
						}
					}
					
					// TODO: check symbolic indices
				}
					
				i++;
			}
		}
		else
		{
			// not an array access => the number of dimensions must be 0
			if (param.getDimensionsCount () != 0)
				errors.SemErr (la.line, la.col, StringUtil.concat ("The parameter dimension of ", strIdentifier, " does not agree with its definition: should be ", param.getDimensionsCount (), ", but is 0."));
		}
	}
	
	private void addSizeParameters (Box box)
	{
		for (Expression expr : box.getMin ())
			addSizeParameter (expr);
		for (Expression expr : box.getMax ())
			addSizeParameter (expr);
	}
	
	private void addSizeParameter (Expression expr)
	{	
		for (DepthFirstIterator it = new DepthFirstIterator (expr); it.hasNext (); )
		{
			Object o = it.next ();
			if (o instanceof NameID)
			{
				if (m_listSizeParameters == null)
					m_listSizeParameters = new LinkedList<> ();
			
				if (!m_listSizeParameters.contains (o))
				{
					m_listSizeParameters.add ((NameID) o);
					
					ensureScalarsMapCreated ();
					m_mapScalars.put (((NameID) o).getName (), new StencilCalculation.ParamType (Globals.SPECIFIER_SIZE));
				}
			}
		}		
	}
		
	private IntArray getStart (List<Range> list)
	{
		int[] rgStart = new int[list.size ()];
		int i = 0;
		
		for (Range range : list)
		{
			rgStart[i] = range.getStart ();
			i++;
		}
		
		return new IntArray (rgStart);
	}

	/**
	 * Adds the parameters to the StencilCalculation object 
	 */	
	private void setStencilOperationArguments ()
	{
        if (m_listStencilOperationArguments != null)
        {
            for (String strIdentifier : m_listStencilOperationArguments)
            {
                StreamIndex idx =  m_mapInputStreams.get (strIdentifier);
                m_stencil.addStencilOperationArgument (
                    strIdentifier,
                    idx == null ? null : idx.getStreamDimensions (),
                    m_mapScalars == null ? null : m_mapScalars.get (strIdentifier));
            }
        }
        
        if (m_listSizeParameters != null)
        {
        	for (NameID nid : m_listSizeParameters)
        		m_stencil.addSizeParameter (nid);
        }
	}
	
	private void checkDefinitions ()
	{
		if (m_stencil.getDomainSize () == null)
			errors.SemErr ("No domainsize defined in the stencil specification.");
		//if (!m_bIterateWhileSet)
		//	errors.SemErr ("No 'iterate while ...' defined in the stencil specification.");
		if (m_stencil.getStencilBundle () == null)
			errors.SemErr ("No stencil operation defined in the stencil specification.");
	}
	
	private static boolean containsStencilNode (Expression expr)
	{
		for (DepthFirstIterator it = new DepthFirstIterator (expr); it.hasNext (); )
			if (it.next () instanceof StencilNode)
				return true;
		return false;
	}
	
	private static List<Expression> getNegSpatialCoords (int nDimensionality)
	{
		List<Expression> l = new ArrayList<> (nDimensionality);
		for (int i = 0; i < nDimensionality; i++)
			l.add (new UnaryExpression (UnaryOperator.MINUS, new NameID (CodeGeneratorUtil.getDimensionName (i))));
		return l;
	}
	
	private static List<Expression> getNegTemporalCoord ()
	{
		List<Expression> l = new ArrayList<> (1);
		l.add (new UnaryExpression (UnaryOperator.MINUS, new NameID ("t")));
		return l;
	}
			

	///////////////////////////////////////////////////////////////////////////
	// LL(1) Conflict Resolvers
	
	/**
	 * Determines whether the next token is a grid variable.
	 * @return <code>true</code> iff the next token is a grid variable
	 */
	private boolean isGridVariable ()
	{
		String strIdentifier = la.val;
		boolean bResult = m_mapInputStreams == null ? false : m_mapInputStreams.containsKey (strIdentifier);
		if (bResult)
			return true;
		bResult = m_mapOutputStreams == null ? false : m_mapOutputStreams.containsKey (strIdentifier);
		if (bResult)
			return true;
			
		return false;
	}
	
	/**
	 * Determines whether the next token is a const grid variable.
	 * @return <code>true</code> iff the next token is a const grid variable
	 */
	private boolean isConstGridVariable (String strIdentifier)
	{
		boolean bResult = m_mapInputStreams == null ? false : m_mapInputStreams.containsKey (strIdentifier);
		if (bResult)
		{
			StreamIndex idx = m_mapInputStreams.get (strIdentifier);
			return idx.isConstant ();
		}
			
		return false;
	}

	/**
	 * LL1 conflict resolver for function calls.
	 */
	private boolean isFunctionCall ()
	{
		Token token = scanner.Peek ();
		scanner.ResetPeek ();
		return token.val.equals ("(");
	}
	

///////////////////////////////////////////////////////////////////////////
// Tokens

CHARACTERS
	letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit = "0123456789".
	cr = '\r'.
	lf = '\n'.
	tab = '\t'.

TOKENS
	ident = letter { letter | digit }.
    integer = digit { digit }.
    pi = "Ï€".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab


///////////////////////////////////////////////////////////////////////////
// Productions

PRODUCTIONS                                                                    // SEMANTIC ACTIONS


    ///////////////////////////////////////////////////////////////////////
    // Stencil Description
    //
    // Example input:
    //
    // ----------------------------------------------------------------------------------------------
    // stencil example_stencil (float grid u(0..x_max, 0..y_max, 0..z_max), float param epsilon = 1e-5)
    // {
    //     iterate while sum((u[x,y,z;t+1]-u[x,y,z;t])^2) > epsilon;
    //
    //     domainsize = (0..x_max, 0..y_max, 0..z_max);
    //
    //     operation
    //     {
    //         u[x,y,z;t+1] = -4*u[x,y,z;t] + u[x-1,y,z;t] + u[x+1,y,z;t] + ...
    //     }
    //
    //     boundaries
    //     {
    //         u[0,y,z;t+1] = 0;
    //         u[x,0,z;t+1] = u[x,y_max-1,z;t];
    //     }
    //
    //     initial
    //     {
    //         u[x,y,z; 0] = 0;
    //         u[x,y,z; 0] = sin(x)*sin(y)*sin(z);
    //         u[0 <= x <= x_max/2, y, z; 0] = 5;
    //           u[x,y,z; 0 : 0<=x<=x_max/2] = 5;
    //         u[x,y,z; 0 : x^2+y^2+z^2 <= x_max/5] = 10;
    //     }
    // }
    // ----------------------------------------------------------------------------------------------
    

	// -------- Stencil Object Declaration --------
	
	/**
	 * The stencil object. Entry point for the stencil grammar.
	 */
    StencilSpecification =                        
        SYNC "stencil"
        ident                                                                  (. m_stencil = new StencilCalculation (t.val); .)
        '(' StencilOperationParamList ')'
        '{'
        {
        	StencilOptions
        	|
        	StencilIterateWhile<out Expression exprIterateWhile>               (. if (m_bIterateWhileSet) errors.SemErr (la.line, la.col, "Found multiple 'iterate while ...' definitions. All but the first one are ignored."); else { m_stencil.setIterateWhile (exprIterateWhile); m_bIterateWhileSet = true; } .)
        	|
        	StencilDomainSize<out Box boxGrid>                                 (. if (m_stencil.getDomainSize () != null) errors.SemErr (la.line, la.col, "Found multiple grid size definitions. All but the first one are ignored."); else m_stencil.setDomainSize (boxGrid); .)
        	|
        	StencilOperation<out StencilBundle bundle>                         (. if (m_stencil.getStencilBundle () != null) errors.SemErr (la.line, la.col, "Found multiple stencil definitions. All but the first are ignored."); else m_stencil.setStencil (bundle); .)
        	|
        	StencilBoundaries<out StencilBundle bundle>                        (. if (m_stencil.getBoundaries () != null) errors.SemErr ("Found multiple boundaries definitions. All but the first are ignored."); else m_stencil.setBoundaries (bundle); .)
        	|
       		StencilInitial<out StencilBundle bundle>                           (. if (m_stencil.getInitialization () != null) errors.SemErr ("Found multiple initializations. All but the first are ignored."); else m_stencil.setInitialization (bundle); .)
        }
        '}'                                                                    (. setStencilOperationArguments (); checkDefinitions (); if (!m_bIterateWhileSet) m_stencil.setMaxIterations (new IntegerLiteral (1)); .)
        .

	StencilOptions =
		SYNC "options" '{'
		{
			StencilOptionsCompatibility ';'
		}
		'}'.
		
	StencilOptionsCompatibility =
		SYNC "compatibility" '='
		(
			"C/C++"                                                            (. m_options.setCompatibility (CodeGenerationOptions.ECompatibility.C); .)
			|
			"Fortran"                                                          (. m_options.setCompatibility (CodeGenerationOptions.ECompatibility.FORTRAN); .)
		).
		        
    /**
     * Defines the temporal iteration space of the stencil.
     */
    StencilIterateWhile<out Expression exprIterateWhile> =
    	SYNC "iterate" "while"                                                 (. Stencil stencilDummy = new Stencil (); .)
    	LogicalExpression<out ExpressionData edIterateWhile, stencilDummy, null, true, false, true, true>
    	                                                                       (. exprIterateWhile = edIterateWhile.getExpression (); .)
    	';'.
      
    /**
     * Defines the spatial iteration space of the stencil.
     */  
    StencilDomainSize<out Box boxGrid> =
    	SYNC "domainsize" '=' StencilBox<out boxGrid> ';'.
    	
    /**
     * The stencil operation.
     */    
	StencilOperation<out StencilBundle bundle> =                               (. bundle = new StencilBundle (m_stencil); .)
		SYNC "operation" Body<bundle, true, true, false>.
        
    /**
     * The boundaries definition.
     * This can be used to define special stencils for boundary points.
     */
	StencilBoundaries<out StencilBundle bundle> =                              (. bundle = new StencilBundle (m_stencil); .)
	 	SYNC "boundaries" Body<bundle, false, true, false>                     (. StencilSpecificationAnalyzer.normalizeStencilNodesForBoundariesAndIntial (bundle); .)
	 	.
		
	/**
	 * Defines the initial condition, i.e., initializes the grids.
	 */
	StencilInitial<out StencilBundle bundle> =                                 (. bundle = new StencilBundle (m_stencil); .)
		SYNC "initial" Body<bundle, false, false, true>                        (. StencilSpecificationAnalyzer.normalizeStencilNodesForBoundariesAndIntial (bundle); .)
		.
		
	Body<StencilBundle bundle, boolean bOffsetInSpace, boolean bOffsetInTime, boolean bIsInitialization> =
		'{'
		{
			AssignmentStatement<bundle, bOffsetInSpace, bOffsetInTime, bIsInitialization>
		}
		'}'.


    StencilBox<out Box box> =
        '('                                                                    (. List<Expression> listMin = new ArrayList<> (); List<Expression> listMax = new ArrayList<> (); .)
        StencilBoxCoordinate<out Box box1>                                     (. listMin.add (box1.getMin ().getCoord (0)); listMax.add (box1.getMax ().getCoord (0)); .)
        {
            ','
            StencilBoxCoordinate<out box1>                                     (. listMin.add (box1.getMin ().getCoord (0)); listMax.add (box1.getMax ().getCoord (0)); .)
        }                                                                      (. Expression[] rgMin = new Expression[listMin.size ()]; Expression[] rgMax = new Expression[listMax.size ()]; listMin.toArray (rgMin); listMax.toArray (rgMax); .)
        ')'                                                                    (. box = new Box (new Point (rgMin), new Point (rgMax)); addSizeParameters (box); .)
        .
        
    StencilBoxCoordinate<out Box box> =
    	StencilExpression<out ExpressionData edMin, null, null, true, true, false, false>
    	".."
    	StencilExpression<out ExpressionData edMax, null, null, true, true, false, false>
    	                                                                       (. box = new Box (new Point (edMin.getExpression ()), new Point (edMax.getExpression ())); .)
    	.

    
	// -------- Stencil Operation --------
        
    /**
     * List of stencil procedure parameters.
     */
    StencilOperationParamList =
        StencilOperationParam
        {
        	',' StencilOperationParam
        }.
        
    /**
     * A parameter to the stencil procedure.
     */
    StencilOperationParam =                                                    (. boolean bIsGridVariable = true; boolean bIsConstant = false; Specifier specVarType = null; Box boxGrid = null; .)
		[
			"const"                                                            (. bIsConstant = true; .)
		]
        (
			"float"                                                            (. specVarType = Specifier.FLOAT; .)
			|
			"double"                                                           (. specVarType = Specifier.DOUBLE; .)
			|
			"int"                                                              (. specVarType = Specifier.INT; .)
			|
			"long"                                                             (. specVarType = Specifier.LONG; .)
    	)
    	(
     		"grid"
   			|
    		"param"                                                            (. bIsGridVariable = false; .)
    	)
        ident                                                                  (. String strIdentifier = t.val; List<Range> listDimensions = new ArrayList<> (); .)
        [
            StencilBox<out boxGrid>                                            (. if (!bIsGridVariable) errors.SemErr (la.line, la.col, "Parameters cannot have a box size declaration"); .)
        ]
        [
        	DimensionDeclarator<listDimensions>                                // register stream variables
        ]                                                                      (. if (bIsGridVariable) { .)
                                                                               (.     registerStream (strIdentifier, specVarType, bIsConstant, boxGrid, listDimensions, EStreamDirection.INPUT); .)
                                                                               (.     if (!bIsConstant) .)
                                                                               (.         registerStream (strIdentifier, specVarType, bIsConstant, boxGrid, listDimensions, EStreamDirection.OUTPUT); .)
                                                                               (. } .)
                                                                               (. else { .)
                                                                               (.     registerScalar (strIdentifier, specVarType, listDimensions, true); .)
                                                                               (.     m_stencil.preAddStencilOperationParameter (strIdentifier, specVarType); .)
                                                                               (. } .)
        [
        	// default value
        	'='                                                                (. if (bIsGridVariable) errors.SemErr (la.line, la.col, "Grid variables can't be assigned a default value. To initialize grids, use the \"initial\" method."); .)
        	                                                                   (. Map<IntArray, Stencil> mapInit = new HashMap<> (); .)
        	ValueInitializer<mapInit, listDimensions, getStart (listDimensions), listDimensions.size () - 1, false, false>
        	                                                                   (. setParamDefaultValues (strIdentifier, mapInit); .)
        ]
        .
        
    DimensionDeclarator<. List<Range> listDimensions .> =
    	'['
    		RangeLiteral<out Range range>                                      (. listDimensions.add (range); .)
    		{
    			SYNC ',' RangeLiteral<out range>                               (. listDimensions.add (range); .)
    		}
    	SYNC ']'
    	.
        
	ValueInitializer<. Map<IntArray, Stencil> mapInitializer, List<Range> listDimensions, IntArray arrCurrCoord, int nDim, boolean bOffsetInSpace, boolean bOffsetInTime .> =
		(
			'{'                                                                (. IntArray arr = new IntArray (arrCurrCoord.get (), true); arr.set (nDim, listDimensions.get (nDim).getStart ()); .)
			ValueInitializer<mapInitializer, listDimensions, arr, nDim - 1, bOffsetInSpace, bOffsetInTime>
			{                                                                  (. arr = new IntArray (arr.get (), true); arr.set (nDim, arr.get (nDim) + 1); .)
				',' ValueInitializer<mapInitializer, listDimensions, arr, nDim - 1, bOffsetInSpace, bOffsetInTime>
			}
			SYNC '}'
			|
			(
			                                                                   (. Stencil stencil = new Stencil (); .)
				StencilExpression<out ExpressionData ed, stencil, null, false, false, bOffsetInSpace, bOffsetInTime>
				                                                               (. if (ed != null) stencil.setExpression (ed); .)
			                                                                   (. mapInitializer.put (arrCurrCoord, stencil); .)
			)
		).
			
        
        
    // -------- Stencil Statements/Expressions --------

	/**
	 * An assignment statement in the stencil operation method.
	 */
    AssignmentStatement<StencilBundle bundle, boolean bOffsetInSpace, boolean bOffsetInTime, boolean bIsInitialization> =
    	(
    		StencilAssignment<bundle, bOffsetInSpace, bOffsetInTime, bIsInitialization>
    		|
    		ScalarAssignment<bundle, bOffsetInSpace, bOffsetInTime, bIsInitialization>
    		|
    		PredicateAssignment
    	)
    	SYNC ';'
    	. 
    	
    ScalarAssignment<StencilBundle bundle, boolean bOffsetInSpace, boolean bOffsetInTime, boolean bIsInitialization> =
                                                                               (. Specifier specType = Specifier.FLOAT; List<Range> listDimensions = new ArrayList<> (); Map<IntArray, Stencil> mapInit = new HashMap<> (); .)
    	(
    		"float"
    		|
    		"double"                                                           (. specType = Specifier.DOUBLE; .)
    	)
    	ident                                                                  (. String strIdentifier = t.val; .)
    	[
    		DimensionDeclarator<listDimensions>
    	]
    	'='                                                                    (. registerScalar (strIdentifier, specType, listDimensions, false); .)
    	ValueInitializer<mapInit, listDimensions, getStart (listDimensions), listDimensions.size () - 1, bOffsetInSpace, bOffsetInTime>
    	                                                                       (. setScalarInitValues (bundle, specType, strIdentifier, mapInit, bOffsetInSpace); .)
/*    	
    	(
    		(
    			'{'
    			StencilExpression<out ExpressionData edRHS, stencil, false, false, bOffsetInSpace, bOffsetInTime>
    			{
    				SYNC ','
    				StencilExpression<out ExpressionData edRHS, stencil, false, false, bOffsetInSpace, bOffsetInTime>
    			}
    			SYNC '}'
    		)
    		|
    		StencilExpression<out ExpressionData edRHS, stencil, false, false, bOffsetInSpace, bOffsetInTime>
    	)
    	StencilExpression<out ExpressionData edRHS, stencil, false, false, bOffsetInSpace, bOffsetInTime>
    	                                                                       (. Expression exprSimplified = null; .)
                                                                               (. if (edRHS.getExpression () instanceof FloatLiteral) .)
                                                                               (.     exprSimplified = edRHS.getExpression (); .)
                                                                               (. else if (!containsStencilNode (edRHS.getExpression ())) .)
                                                                               (.     exprSimplified = Symbolic.simplify (edRHS.getExpression ()); .)
    	                                                                       (. if (exprSimplified instanceof FloatLiteral || exprSimplified instanceof IntegerLiteral) .)
    	                                                                       (.     registerConstant (strIdentifier, (Literal) exprSimplified); .)
    	                                                                       (. else { .)
    	                                                                       (.     registerScalar (strIdentifier, specType, new ArrayList<Integer> (), false); StencilNode node = new StencilNode (strIdentifier, specType, null); stencil.addOutputNode (node); .)
    	                                                                       (.     exprAssignment = new ExpressionData (new AssignmentExpression (node, AssignmentOperator.NORMAL, edRHS.getExpression ()), edRHS.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION); .)
    	                                                                       (. } .)
*/    	                                                                       
    	.
    	
    /**
     * Declare predicates for conditional assignments.
     * TODO.
     */
    PredicateAssignment =
    	"predicate" ident '='
    	LogicalExpression<out ExpressionData expr, null, null, true, true, false, false>
    	.

	/**
	 * The assignment expression in the stencil operation method.
	 */
    StencilAssignment<StencilBundle bundle, boolean bOffsetInSpace, boolean bOffsetInTime, boolean bIsInitialization> =
                                                                               (. Stencil stencil = new Stencil (); .)
    	StencilIdentifier<out StencilNode nodeLHS, null, bIsInitialization ? EStreamDirection.INPUT : EStreamDirection.OUTPUT, bOffsetInSpace, bOffsetInTime>
    	                                                                       (. stencil.addOutputNode (nodeLHS); .)
    	'='
    	StencilExpression<out ExpressionData edRHS, stencil, null, false, false, bOffsetInSpace, bOffsetInTime>
    	                                                                       (. stencil.setExpression ((nodeLHS == null || edRHS == null) ? null : new ExpressionData (new AssignmentExpression (nodeLHS, AssignmentOperator.NORMAL, edRHS.getExpression ()), edRHS.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION)); .)
    	                                                                       (. try { if (!stencil.isEmpty ()) bundle.addStencil (stencil, bOffsetInSpace); } catch (NoSuchMethodException e) { e.printStackTrace (); } .)
    	.

	/**
	 * Reference to a grid variable.
	 */
    StencilIdentifier<out StencilNode node, LocalVars lv, EStreamDirection dir, boolean bOffsetInSpace, boolean bOffsetInTime> =
    	ident                                                                  (. String strIdentifier = t.val; node = null; Index index = new Index (); boolean bVectorIndexSet = false; .)
    	'['
    	StencilExpression<out ExpressionData exprIdx0, null, lv, false, true, false, false>
    		                                                                   (. int nMode = 0; List<Expression> listIndices = new ArrayList<> (); listIndices.add (exprIdx0.getExpression ()); .)
    	{
    		SYNC
    		(
    			','
    			|
    			';'                                                            (. switch (nMode) { .)
    			                                                               (. case 0: index.setSpaceIndex (listIndices, bOffsetInSpace ? getNegSpatialCoords (listIndices.size ()) : null); if (isConstGridVariable (strIdentifier)) nMode++; break; .)
    			                                                               (. case 1: index.setTimeIndex (listIndices, bOffsetInTime ? getNegTemporalCoord () : null); break; .)
    			                                                               (. case 2: index.setVectorIndex (getStreamIndex (strIdentifier, listIndices, dir)); bVectorIndexSet = true; break; .)
    			                                                               (. default: errors.SemErr (la.line, la.col, "Grids can't have more than 3 different index types."); } .)
    			                                                               (. nMode++; listIndices = new ArrayList<> (); .)
    		)
    		StencilExpression<out ExpressionData exprIdx1, null, lv, false, true, false, false>
    			                                                               (. listIndices.add (exprIdx1.getExpression ()); .)
    	}
    	                                                                       (. switch (nMode) { .)
    	                                                                       (. case 0: index.setSpaceIndex (listIndices, bOffsetInSpace ? getNegSpatialCoords (listIndices.size ()) : null); break; .)
    	                                                                       (. case 1: index.setTimeIndex (listIndices, bOffsetInTime ? getNegTemporalCoord () : null); break; .)
    	                                                                       (. case 2: index.setVectorIndex (getStreamIndex (strIdentifier, listIndices, dir)); bVectorIndexSet = true; break; .)
    	                                                                       (. default: errors.SemErr (la.line, la.col, "Grids can't have more than 3 different index types."); } .)
    	                                                                       (. if (!bVectorIndexSet) index.setVectorIndex (getStreamIndex (strIdentifier, null, dir)); .)
    	                                                                       (. StreamIndex si = getStream (strIdentifier, dir); .)
    	                                                                       (. node = new StencilNode (strIdentifier, si == null ? Specifier.DOUBLE : si.getSpecifier (), index); .)
    	[	/* constraints specification (set-builder notation) */
    		':'
    		LogicalExpression<out ExpressionData exprConstr0, null, lv, false, true, false, false>
    		                                                                   (. node.setConstraint (exprConstr0.getExpression ()); .)
    		{
    			','
    			LogicalExpression<out ExpressionData exprConstr1, null, lv, false, true, false, false>
    			                                                               (. node.addConstraint (exprConstr1.getExpression ()); .)
    		}
    	]
		SYNC ']'    	                                                                       
    	.

    /**
     * A scalar.
     */
    ScalarIdentifier<out Expression exprParam, LocalVars lv, boolean bIsDecl, boolean bIsInteger> =
		ident                                                                  (. String strIdentifier = t.val; Literal litValue = getConstantValue (strIdentifier); exprParam = litValue == null ? new NameID (strIdentifier) : litValue; int[] rgIdx = null; .)
		[
	        '['                                                                (. if ((exprParam instanceof FloatLiteral) || (exprParam instanceof IntegerLiteral)) errors.SemErr (la.line, la.col, "Cannot subscript a scalar value"); List<Expression> listIndices = new ArrayList<> (); .)
	        	StencilExpression<out ExpressionData exprIdx0, null, lv, false, true, false, false>
	        	                                                               (. listIndices.add (Symbolic.simplify (exprIdx0.getExpression ())); .)
	        	{
	        		SYNC ','
		        	StencilExpression<out ExpressionData exprIdx1, null, lv, false, true, false, false>
	        	                                                               (. listIndices.add (Symbolic.simplify (exprIdx1.getExpression ())); .)
	        	}
	        SYNC ']'                                                           (. rgIdx = m_au.asIntArray (listIndices); .)
	                                                                           (. if (rgIdx == null) exprParam = new ArrayAccess (new NameID (strIdentifier), listIndices); .)
	                                                                           (. else { .)
	                                                                           (. 	String strIndexedIdentifier = m_au.getIndexedIdentifier (strIdentifier, rgIdx); .)
	                                                                           (.	litValue = getConstantValue (strIndexedIdentifier); .)
	                                                                           (.	if (litValue != null) exprParam = litValue; else exprParam = new NameID (strIndexedIdentifier); .)
	                                                                           (. } .)
		]                                                                      (. if (rgIdx == null && !(exprParam instanceof FloatLiteral) && !(exprParam instanceof IntegerLiteral) && !bIsDecl && (lv == null || !lv.hasVariable (strIdentifier))) .)
		                                                                       (. 	checkParameterIndices (strIdentifier, exprParam, lv); .)
        .
		
	/**
	 * An expression within the stencil's operation method using stencil grid variables.
	 */
	StencilExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDeclaration, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
	                                                                           (. LocalVars lvNew = lv; .)
		[
			SetComprehension<out lvNew, lv>
		]
		AdditiveExpression<out ExpressionData exprAdd, stencil, lvNew, bIsDeclaration, bIsInteger, bOffsetInSpace, bOffsetInTime>
		                                                                       (. expr = exprAdd; /*expr = exprAdd == null ? null : NormalExpression.simplify (exprAdd);*/ .)
		.
		
	SetComprehension<out LocalVars lvNew, LocalVars lv> =
		'{'                                                                    (. lvNew = lv == null ? new LocalVars () : lv; .)
		RangeDeclaration<lvNew>
		{
			','
			RangeDeclaration<lvNew>
		}
		[
    		':'
    		LogicalExpression<out ExpressionData exprConstr0, null, lvNew, false, true, false, false>
    		                                                                   (. lvNew.addPredicate (exprConstr0.getExpression ()); .)
    		{
    			','
    			LogicalExpression<out ExpressionData exprConstr1, null, lvNew, false, true, false, false>
    			                                                               (. lvNew.addPredicate (exprConstr1.getExpression ()); .)
    		}
		]
		'}'
		.
		
	RangeDeclaration<LocalVars lv> =
		ident                                                                  (. String strVarName = t.val; .)
		'='
		RangeLiteral<out Range range>                                          (. lv.addVariable (strVarName, range); .)
		. 
		
	/**
	 * A logical expression using stencil grid variables.
	 */
	LogicalExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDeclaration, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
		OrExpression<out expr, stencil, lv, bIsDeclaration, bIsInteger, bOffsetInSpace, bOffsetInTime>.
		
	OrExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
		AndExpression<out ExpressionData expr0, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
		                                                                       (. expr = expr0; .)
		{
			(
				"||"
				|
				"or"
			)
			AndExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
			                                                                   (. expr = new ExpressionData (new BinaryExpression (expr.getExpression (), BinaryOperator.LOGICAL_OR, expr1.getExpression ()), expr.getFlopsCount () + expr1.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION); .)
		} 
		.
		
	AndExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
		NotExpression<out ExpressionData expr0, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
		                                                                       (. expr = expr0; .)
		{
			(
				"&&"
				|
				"and"
			)
			NotExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
			                                                                   (. expr = new ExpressionData (new BinaryExpression (expr.getExpression (), BinaryOperator.LOGICAL_AND, expr1.getExpression ()), expr.getFlopsCount () + expr1.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION); .)
		} 
		.
		
	NotExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
	                                                                           (. UnaryOperator op = null; .)
		[
			"!"                                                                (. op = UnaryOperator.LOGICAL_NEGATION; .)
			|
			"not"                                                              (. op = UnaryOperator.LOGICAL_NEGATION; .)
		]
		ComparisonExpression<out expr, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
		                                                                       (. if (op != null) expr = new ExpressionData (new UnaryExpression (op, expr.getExpression ()), expr.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION); .)
		.
		
	/**
	 * A comparison expression of the form
	 *     a {op} b
	 * or
	 *     a1 {op} b {op} a2
	 * where {op} is one of '<', '<=', '==', '>=', '>', '!='.
	 * The second form translates to "(a1 {op} b) and (b {op} a2)"
	 */
	ComparisonExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
	                                                                           (. BinaryOperator op0 = null; BinaryOperator op1 = null; .)
		AdditiveExpression<out ExpressionData expr0, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
		                                                                       (. expr = expr0; .)
		[
			ComparisonOperator<out op0>
			AdditiveExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
			                                                                   (. expr = new ExpressionData (new BinaryExpression (expr.getExpression (), op0, expr1.getExpression ()), expr.getFlopsCount () + expr1.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION); .)
			[
				ComparisonOperator<out op1>
				AdditiveExpression<out ExpressionData expr2, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
				                                                               (. expr = new ExpressionData (new BinaryExpression (expr.getExpression (), BinaryOperator.LOGICAL_AND, new BinaryExpression (expr1.getExpression ().clone (), op1, expr2.getExpression ())), expr.getFlopsCount () + expr2.getFlopsCount (), Symbolic.EExpressionType.EXPRESSION); .)
			]
		]
		.
		
	ComparisonOperator<out BinaryOperator op> =                                (. op = null; .)
		(
			'<'                                                                (. op = BinaryOperator.COMPARE_LT; .)
			|
			"<="                                                               (. op = BinaryOperator.COMPARE_LE; .)
			|
			"=="                                                               (. op = BinaryOperator.COMPARE_EQ; .)
			|
			">="                                                               (. op = BinaryOperator.COMPARE_GE; .)
			|
			'>'                                                                (. op = BinaryOperator.COMPARE_GT; .)
			|
			"!="                                                               (. op = BinaryOperator.COMPARE_NE; .)
			|
			"/="                                                               (. op = BinaryOperator.COMPARE_NE; .)
		).
		
	/**
	 * An additive expression. Supports addition and subtraction.
	 */
    AdditiveExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
                                                                               (. List<ExpressionData> listSummands = new LinkedList<> (); boolean bAdd = true; expr = null; .)
        MultiplicativeExpression<out ExpressionData expr0, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
                                                                               (. listSummands.add (expr0); .)
        {
        	(
        		'+'                                                            (. bAdd = true; .)
        		|
        		'-'                                                            (. bAdd = false; expr = m_au.sum (listSummands, bIsInteger); listSummands.clear (); .)
        	)
        	MultiplicativeExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        	                                                                   (. if (bAdd) listSummands.add (expr1); else listSummands.add (m_au.subtract (expr.clone (), expr1, bIsInteger)); .)
        }                                                                      (. expr = m_au.sum (listSummands, bIsInteger); .)
        .
        
    /**
     * A multiplicative expression. Supports (floating point)
     * multiplication and division.
     */
    MultiplicativeExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
                                                                               (. List<ExpressionData> listFactors = new LinkedList<> (); BinaryOperator op = null; expr = null; .)
        UnarySignExpression<out ExpressionData expr0, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
                                                                               (. listFactors.add (expr0); .)                      
        {
        	(
        		'*'                                                            (. op = BinaryOperator.MULTIPLY; .)
        		|
        		'/'                                                            (. op = BinaryOperator.DIVIDE; .)
        		|
        		'%'                                                            (. if (!bIsInteger) { errors.SemErr (la.line, la.col, "The % operator is only defined for integers"); } .)
        		                                                               (. else { op = BinaryOperator.MODULUS; expr = m_au.product (listFactors, bIsInteger); listFactors.clear (); } .)
        	)
        	UnarySignExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        	                                                                   (. if (op == BinaryOperator.MULTIPLY) listFactors.add (expr1); .)
        	                                                                   (. else if (op == BinaryOperator.DIVIDE) { .)
        	                                                                   (.	if ((expr1.getExpression () instanceof Literal) && !bIsInteger) .)
        	                                                                   (. 		listFactors.add (new ExpressionData (new FloatLiteral (1.0 / ExpressionUtil.getFloatValue (expr1.getExpression ())), 0, Symbolic.EExpressionType.EXPRESSION)); .)
        	                                                                   (.	else { .)
																			   (. 		expr = m_au.product (listFactors, bIsInteger); listFactors.clear (); .)
																			   (. 		listFactors.add (m_au.divide (expr.clone (), expr1, bIsInteger)); .)
        	                                                                   (.	} .)
        	                                                                   (. } .)
        	                                                                   (. else if (op == BinaryOperator.MODULUS) listFactors.add (m_au.modulus (expr.clone (), expr1, bIsInteger)); .)
        	                                                                   (. else errors.SemErr (la.line, la.col, "No multiplicative operator defined"); .)
        }                                                                      (. expr = m_au.product (listFactors, bIsInteger); .)
        .
        
    UnarySignExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
                                                                               (. boolean bIsNegative = false; .) 
        [
            '+'
            |
            '-'                                                                (. bIsNegative = true; .)
        ]
        ExponentExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
                                                                               (. if (!bIsNegative) expr = expr1; else { .)
                                                                               (.     if (expr1.getExpression () instanceof FloatLiteral) expr = new ExpressionData (new FloatLiteral (-((FloatLiteral) expr1.getExpression ()).getValue ()), 0, Symbolic.EExpressionType.EXPRESSION); .)
                                                                               (.     else if (expr1.getExpression () instanceof IntegerLiteral) expr = new ExpressionData (new IntegerLiteral (-((IntegerLiteral) expr1.getExpression ()).getValue ()), 0, Symbolic.EExpressionType.EXPRESSION); .)
                                                                               (.     else expr = new ExpressionData (new UnaryExpression (UnaryOperator.MINUS, expr1.getExpression ()), expr1.getFlopsCount () + 1, Symbolic.EExpressionType.EXPRESSION); .)
                                                                               (. } .)
        .
       
    /**
     * The power operator.
     */ 
    ExponentExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
        UnaryExpression<out expr, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        {
        	'^'
        	UnaryExpression<out ExpressionData expr1, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        	                                                                   (. expr = expr == null ? null : ExpressionUtil.createExponentExpression (expr.clone (), expr1, null); .)
        	                                                                   /* Note: we don't use a data type specifier here, so the generic functions (exp, sqrt, pow) will be used. */
        	                                                                   /* TODO: replace the generic function with the specific one (for double/single precision) later (at backend function mapping time)! */
        }.
        
    /**
     * A unary expression involving stencil variables.
     */
    UnaryExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
                                                                               (. expr = null; .)
        (
        	NumberLiteral<out double fValue, bIsInteger>                       (. expr = new ExpressionData (m_au.createLiteral (fValue, bIsInteger), 0, Symbolic.EExpressionType.EXPRESSION); .)
        	|
        	IF(isGridVariable ())
        		StencilIdentifier<out StencilNode node, lv, EStreamDirection.INPUT, bOffsetInSpace, bOffsetInTime>
        		                                                               (. expr = new ExpressionData (node, 0, Symbolic.EExpressionType.EXPRESSION); .)
        		                                                               (. if (lv == null) stencil.addInputNode (node); else for (ExpressionData edNode : lv.expand (node)) stencil.addInputNode ((StencilNode) edNode.getExpression ()); .)
        	|
        	BracketedExpression<out ExpressionData exprBracketed, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        	                                                                   (. expr = exprBracketed; .)
        	|
        	IF(isFunctionCall ())
        	    FunctionCall<out ExpressionData exprFnxValue, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        	                                                                   (. expr = exprFnxValue; .)
        	|
        	ScalarIdentifier<out Expression exprParam, lv, bIsDecl, bIsInteger>
        	                                                                   (. expr = new ExpressionData (exprParam, 0, Symbolic.EExpressionType.EXPRESSION); .)
        ).
        
    /**
     * A bracketed expression.
     */
    BracketedExpression<out ExpressionData expr, Stencil stencil, LocalVars lv, boolean bIsDeclaration, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
        '('
        	StencilExpression<out expr, stencil, lv, bIsDeclaration, bIsInteger, bOffsetInSpace, bOffsetInTime>
        ')'.
        
    /**
     * A function call.
     */
    FunctionCall<out ExpressionData fnx, Stencil stencil, LocalVars lv, boolean bIsDecl, boolean bIsInteger, boolean bOffsetInSpace, boolean bOffsetInTime> =
        ident                                                                  (. String strFunctionName = t.val; .)
        '('                                                                    (. List<Expression> listArgs = new ArrayList<> (); int nFlopsCount = 0; .)
        	[
        		StencilExpression<out ExpressionData expr, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        		                                                               (. listArgs.add (expr.getExpression ()); nFlopsCount += expr.getFlopsCount (); .)
        		{
        			SYNC ',' StencilExpression<out expr, stencil, lv, bIsDecl, bIsInteger, bOffsetInSpace, bOffsetInTime>
        			                                                           (. listArgs.add (expr.getExpression ()); nFlopsCount += expr.getFlopsCount (); .)
        		}
        	]
        ')'                                                                    (. fnx = m_au.isCompileTimeReduction (strFunctionName, listArgs, lv, la) ? .)
                                                                               (. 	m_au.replaceIndexedScalars (m_au.expandCompileTimeReduction (strFunctionName, listArgs, lv, la), m_mapScalars, m_mapConstants, la) : .)
                                                                               (. 	new ExpressionData (new FunctionCall (new NameID (strFunctionName), listArgs), nFlopsCount + 1, Symbolic.EExpressionType.EXPRESSION); .)
        .


    ///////////////////////////////////////////////////////////////////////
    // General Types
		
	NumberLiteral<out double fValue, boolean bIsInteger> =                     (. fValue = 0.0; .)
		(
			IF(!bIsInteger)
				FloatLiteral<out fValue>
			|
			integer                                                            (. fValue = Integer.parseInt (t.val); .)
		)
		.
		
	IntegerLiteral<out int nValue> =
		integer                                                                (. nValue = Integer.parseInt (t.val); .)
		.
		
	PosNegIntegerLiteral<out int nValue> =                                     (. boolean bIsNeg = false; .)
		[
			'+'
			|
			'-'                                                                (. bIsNeg = true; .)
		]
		IntegerLiteral<out nValue>                                             (. if (bIsNeg) nValue = -nValue; .)
		.
		
	FloatLiteral<out double fValue> =                                          (. fValue = 0.0; .)
		(
			pi                                                                 (. fValue = Math.PI; .)
			|
			(                                                                  (. StringBuilder sb = new StringBuilder (); .)
				[
					integer                                                    (. sb.append (t.val); .)
				]
				[
					'.'                                                        (. sb.append (t.val); .)
					[
						integer                                                (. sb.append (t.val); .)
					]
				]
				[
					(
						"e+"                                                   (. sb.append (t.val); .)
						|
						"e-"                                                   (. sb.append (t.val); .)
					)
					integer                                                    (. sb.append (t.val); .)
				]                                                              (. fValue = Double.parseDouble (sb.toString ()); .)
			)
		).
	
	RangeLiteral<out Range range> =                                            (. int nEnd = -1; boolean bHasEnd = false; .)
		(
			PosNegIntegerLiteral<out int nStart>
			[
				".."
				PosNegIntegerLiteral<out nEnd>                                 (. bHasEnd = true; .)
			]                                                                  (. range = bHasEnd ? new Range (nStart, nEnd) : new Range (0, nStart - 1); .)
		). 
		
END StencilSpecification.
