package cetus.analysis;

import java.util.*;
import java.io.*;
import cetus.hir.*;
import cetus.transforms.*;
import cetus.analysis.PointsToDomain.Universe;

/**
 * The Points-To Analyzer creates intraprocedural pointer 
 * relationships for C programs. Pointer variables are 
 * variables that store the address-value of a memory 
 * location and are said to point-to or reference that 
 * memory location. The points-to analyzer implemented 
 * here is flow sensitive and hence, provides pointer 
 * relationships at every program point i.e. every 
 * relevant Statement in the program. Pointer relationships 
 * are represented using {@link PointsToDomain} and 
 * {@link PointsToRel}, which make use of different 
 * {@link Symbol} information to a large extent. Aggregate 
 * structures such as arrays are handled conservatively, 
 * while struct types are handled more precisely. The 
 * analyzer also supports useful, but conservative, 
 * information handling for heap-allocated variables.
 * <p>
 * The analyzer is directly used by the Interprocedural 
 * Points-to Analyzer, to provide advanced static-time 
 * pointer information. Thus, function calls inside of 
 * procedures can be supported during intraprocedural 
 * analysis.
 * <p>
 * The analysis is implemented based on the design 
 * described in the following M.S. Thesis:
 * <p>
 * "A Practical Interprocedural Alias Analysis for an 
 * Optimizing/Parallelizing C Compiler", Maryam Emami, 1993.
 * 
 * @see PointsToDomain
 * @see PointsToRel
 * @see IPPointsToAnalysis
 */
public class PointsToAnalysis extends AnalysisPass {

	public static Set<String> standard_lib_pointers
	= new HashSet(Arrays.asList("stdin", "stdout", "stderr"));
	
	public PointsToAnalysis(Program program)
	{
		super(program);
	}

	public String getPassName()
	{
		return "[POINTS-TO-ANALYSIS]";
	}

	/**
	 * Simple intraprocedural analysis can be run for a procedure that 
	 * does not have pointers in formal parameters. Use only for simple 
	 * testing or understanding. Annotates the output source code 
	 * with pointer-relationship information. 
	 * <p>
	 * For complete use of points-to information, 
	 * use interprocedural points-to analysis, which directly uses 
	 * information generated by the intraprocedural analyzer.
	 */
	public void start()
	{
		// IR Normalization passes for Points To analysis
		TransformPass.run(new NormalizeReturn(program));

		List<Procedure> proc_list = IRTools.getProcedureList(program);

		for (Procedure proc : proc_list) 
		{
			Map map = getPointsToRelations(proc);
			annotatePointsTo(proc, map);
		}
	}

	/**
	 * Use during interprocedural points-to analysis to get points-to relations
	 * for the current procedure node {@link IPANode}. 
	 * Returns map from each statement 
	 * in the procedure to points-to relationships at(right before) the 
	 * statement is executed
	 * @param proc_node Procedure Node analyzed for points to information
	 * @return Map from statement to points-to domain
	 * @see PointsToDomain
	 */
	protected static Map getPointsToRelations(IPANode proc_node)
	{
		Procedure proc = proc_node.getProcedure();

		// Create a map to store points-to information at each 
		// program point. This map is from a Statement to the 
		// pointer information that exists before the statement.
		LinkedHashMap stmt_rel_domain = new LinkedHashMap<Statement,
		Domain>();

		// Build a control flow graph for the procedure, for flow-
		// sensitive analysis
		CFGraph cfg = new CFGraph(proc);
		DFANode entry = cfg.getNodeWith("stmt", "ENTRY");

		// Maintain a list of nodes that must be processed for points 
		// to information. Nodes are processed in reverse post-order 
		// as provided by topological ordering (optimized)
		TreeMap<Integer, DFANode> node_list = new TreeMap<Integer, DFANode>();
		// Add all the nodes to the work-list, this takes care of the
		// first pass through the cfg in topological order.
		// Later, only successors for nodes that have different in and
		// out points-to domains are added back to the work list for 
		// subsequent iterations
		// =========================================================
		cfg.topologicalSortOptimized(entry);
		node_list.clear();
		Iterator<DFANode> iter = cfg.iterator();
		while (iter.hasNext())
		{
			DFANode node = iter.next();
			node_list.put((Integer)node.getData("top-order"),
					node);

		}
		stmt_rel_domain = traverseWorkList(proc_node, node_list);
		// =========================================================
		return stmt_rel_domain;
	}

	/*
	 * Uses worklist based traversal to iterate over all the nodes 
	 * in the control flow graph until a fixed-point is reached i.e. 
	 * there is no change in information from the previous 
	 * iteration to the current.
	 */
	private static LinkedHashMap traverseWorkList(
			IPANode proc_node,
			TreeMap<Integer, DFANode> node_list)
	{
		Procedure proc = proc_node.getProcedure();

		// Create a map to store points-to information at each 
		// program point. This map is from a Statement to the 
		// pointer information that exists before the statement.
		LinkedHashMap stmt_rel_domain = new LinkedHashMap
		<Statement, Domain>();
		
		// Points-to Domains that are used during the 
		// data-flow update
		// IN
		Domain in_domain = null;
		// OUT
		Domain out_domain = null;
		
		// Domain to hold information generated by initializers
		// inside new scope
		Domain enterscope_domain = null;
		
		while (!node_list.isEmpty()) {
			Integer node_index = node_list.firstKey();
			DFANode curr_node = node_list.remove(node_index);

			// ----------------- IN DOMAIN ---------------------------
			// Found an entry node, create empty points to set
			if (curr_node.getPreds().isEmpty()) 
			{
				// Entry node points-to information must be mapped 
				// from what gets passed into the procedure
				// This could be passed in from various call sites
				// If we're doing context-insensitive analysis, these 
				// incoming data must be "merged" conservatively
				// Currently using the functionality provided by 
				// IPANode in(). See IPPointsToAnalysis for more 
				// information
				in_domain = proc_node.in();
				if (in_domain == null)
					in_domain = new NullDomain();
			}
			else
				in_domain = null;

			// Get points-to information for predecessors, merge 
			// and update IN for this node
			for (DFANode pred : curr_node.getPreds()) {
				Domain pred_domain = (Domain)
				pred.getData("points-to");
				// Predecessor domain data is null, must be coming from a
				// back edge
				if (pred_domain == null)
				{
					continue;
				}
				if (curr_node.getPreds().size() == 1 ||
						in_domain==null)
				{
					in_domain = pred_domain.clone();
				}				
				else
				{
					in_domain = 
						PointsToDomain.merge(
								in_domain,
								pred_domain);
				}
			}

			// --------------------- INITIALIZER RELATED --------------------
			// Having determined in_domain, check if this node is entry 
			// point for new scope
			// If this node is also a symbol table entry point
			// i.e. creation of new scope, then
			// do points-to information preprocessing for pointer
			// initialization in the entry declarations for this 
			// scope. This is accessed via "symbol-entry"
			enterscope_domain = enterScope(curr_node,
					in_domain,
					proc_node,
					stmt_rel_domain);
			if ( enterscope_domain != null )
			{
				// Update IN if necessary
				in_domain = enterscope_domain.clone();
			}

			// --------------------- STATEMENT POINTS TO INFO ---------------
			// First get the statement object to which the current incoming
			// points-to information must be attached 
			Object s_stmt = curr_node.getData("stmt");
			if (s_stmt != null && s_stmt != "ENTRY")
				stmt_rel_domain.put(s_stmt, in_domain);

			// Get the ir associated with the current node, analyze for
			// points-to information if statement
			// One case where this distinction between "ir" and "stmt" must
			// be made is ForLoop where the entry node for the ForLoop 
			// contains the entire loop for "stmt" and hence must be used 
			// for attachment of points-to domain but contains the initialization
			// statement for "ir" which must be analyzed for points-to updates
			Object s_ir = curr_node.getData("ir");
			// ---------------- OUT DOMAIN ----------------------------------
			// Only process for ExpressionStatements, the assignment and 
			// function call constructs we're especially interested in 
			// come as children of ExpressionStatement
			if (s_ir instanceof ExpressionStatement
					&& !(in_domain instanceof Universe)
					&& !(in_domain instanceof NullDomain)) 
			{
				// Process the points to relations for this stmt
				out_domain = basicPointsTo(curr_node, in_domain, proc_node);
			}
			else 
			{
				out_domain = in_domain.clone();
			}

			// Add the successors of this node if there is an update in the 
			// points to relations
			Domain last_domain = curr_node.getData("points-to");
			if (last_domain == null ||
					!out_domain.equals(last_domain))
			{				
				for (DFANode succ : curr_node.getSuccs())
					node_list.put((Integer)succ.getData("top-order"),
							succ);
			}
			curr_node.putData("points-to", out_domain);
		}
		return stmt_rel_domain;
	}
	
	/*
	 * For intraprocedural points-to analysis, first create a control 
	 * flow graph of the procedure. Traverse each statement in the 
	 * CFG (each node in CFGraph). Provide statement and input 
	 * relationships to points-to algorithm. Obtain output set of 
	 * points to relationships. Propagate forward and iterate over 
	 * the CFG until all nodes have been analyzed and a fixed 
	 * point is reached.
	 */
	private static Map getPointsToRelations(Procedure proc)
	{
		// Points to sets
		Domain in_domain = null;
		Domain out_domain = null;
		// At each program point
		LinkedHashMap stmt_rel_domain = new LinkedHashMap<Statement,
		Domain>();

		// Domain to hold information generated by initializers
		// inside new scope
		Domain enterscope_domain = null;

		// Build a control flow graph for the procedure
		CFGraph cfg = new CFGraph(proc);
		DFANode entry = cfg.getNodeWith("stmt", "ENTRY");
		cfg.topologicalSort(entry);

		// Maintain a list of nodes that must be processed for points 
		// to information. Nodes are processed in reverse post-order 
		// as provided by topological ordering
		TreeMap<Integer, DFANode> node_list = new TreeMap<Integer, DFANode>();
		// Add all the nodes to the work-list, this takes care of the
		// first pass through the cfg in topological order.
		// Later, only successors for nodes that have different in and
		// out points to domains are added back to the work list for 
		// another pass
		Iterator<DFANode> iter = cfg.iterator();
		while (iter.hasNext())
		{
			DFANode node = iter.next();
			node_list.put((Integer)node.getData("top-order"),
					node);
		}

		while (!node_list.isEmpty()) {
			Integer node_index = node_list.firstKey();
			DFANode curr_node = node_list.remove(node_index);

			// Found an entry node, create empty points to set
			if (curr_node.getPreds().isEmpty()) 
			{
				// Entry node points to information must be mapped 
				// from what gets passed into the procedure
				// For "only" intra analysis, its empty
				in_domain = new PointsToDomain();
			}
			else
				in_domain = null;

			// Get points-to information for predecessors, merge 
			// and update for this statement
			for (DFANode pred : curr_node.getPreds()) {
				Domain pred_domain = pred.getData("points-to");
				// Predecessor domain data is null, must be coming from a
				// back edge
				if (pred_domain == null)
				{
					//testSetBackEdge(curr_node);
					continue;
				}
				if (curr_node.getPreds().size() == 1 ||
						in_domain==null)
				{
					in_domain = pred_domain.clone();
				}				
				else
				{						
					in_domain = 
						PointsToDomain.merge(
								in_domain,
								pred_domain);
				}
			}

			// Having determined in_domain, check if this node is entry 
			// point for new scope
			// If this node is also a symbol table entry point
			// i.e. creation of new scope, then
			// do points-to information preprocessing for pointer
			// initialization in the entry declarations for this 
			// scope. This is accessed via "symbol-entry"
			enterscope_domain = enterScope(curr_node,
					in_domain,
					null,
					stmt_rel_domain);
			if ( enterscope_domain != null )
			{
				in_domain = enterscope_domain.clone();
			}

			// Process the points to relations for this stmt
			// First get the statement object to which the current incoming
			// points-to information must be attached 
			Object s_stmt = curr_node.getData("stmt");
			if (s_stmt != null && s_stmt != "ENTRY")
				stmt_rel_domain.put(s_stmt, in_domain);

			// Get the ir associated with the current node, analyze for
			// points-to information if statement
			// One case where this distinction between "ir" and "stmt" must
			// be made is ForLoop where the entry node for the ForLoop 
			// contains the entire loop for "stmt" and hence must be used 
			// for attachment of points-to domain but contains the initialization
			// statement for "ir" which must be analyzed for points-to updates
			Object s_ir = curr_node.getData("ir");
			if (s_ir instanceof ExpressionStatement
					&& !(in_domain instanceof Universe)
					&& !(in_domain instanceof NullDomain)) 
			{
				out_domain = basicPointsTo(curr_node, in_domain, null);
			}
			else
			{
				out_domain = in_domain.clone();
			}

			// Add the successors of this node if there is an update in the 
			// points to relations
			Domain last_domain = curr_node.getData("points-to");
			if (last_domain == null ||
					!out_domain.equals(last_domain))
			{
				for (DFANode succ : curr_node.getSuccs())
					node_list.put((Integer)succ.getData("top-order"),
							succ);
			}
			curr_node.putData("points-to", out_domain);

		}

		return stmt_rel_domain;
	}

	/*
	 * Handles the specific consideration of important constructs 
	 * inside of ExpressionStatements that we're interested in. 
	 * Separately invokes assignment updates and function call 
	 * updates as required.
	 */
	private static Domain basicPointsTo(
			DFANode node, 
			Domain input,
			IPANode proc_node)
	{
		Set<Specifier> ignorable_specs = new HashSet(
				Arrays.asList(
						Specifier.BOOL, Specifier.BOOLEAN,
						Specifier.BYTE, Specifier.CBOOL,
						Specifier.CCOMPLEX, Specifier.CIMAGINARY));
		Statement stmt = null;
		Object s = node.getData("ir");
		if (s instanceof Statement)
			stmt = (Statement)s;
		else
			return null;

		Domain output = null;

		List<Traversable> t_list = stmt.getChildren();
		for (Traversable t : t_list)
		{
			// Check for points-to assignments for pointer 
			// expressions and update the points-to sets accordingly
			if (t instanceof AssignmentExpression)
			{
				AssignmentExpression assign = 
					(AssignmentExpression)t;
				Expression lhs = assign.getLHS();
				Expression rhs = assign.getRHS();

				Symbol lhs_symbol = exprToLocation(lhs);
				if (lhs_symbol!=null && 
						SymbolTools.isPointer(lhs_symbol))
				{
					// Temporary elimintation to avoid any pointer 
					// types that we do not consider.
					List<Specifier> specs = lhs_symbol.getTypeSpecifiers();
					for (Specifier spec : specs)
					{
						if (ignorable_specs.contains(spec))
						{
							output = input.clone();
							break;
						}
					}
					// Normalization is important for simplifying 
					// different corner cases as required by the 
					// analysis
					Expression lhs_normalized = normalizePointsTo(lhs);
					Expression rhs_normalized = normalizePointsTo(rhs);

					Domain assigned;

					// ------------------ ASSIGNMENT HANDLING --------------
					// If the rhs is a function call, use interprocedural
					// information (if available)
					if ( IRTools.containsClass((Traversable)rhs, FunctionCall.class) )
					{
						// Intra-procedural analysis
						if ((proc_node == null))
							assigned = Universe.getUniverse();
						else
							// Use return value information for functions 
							// that return pointers e.g. malloc
							assigned = 
								processFunctionAssignment(lhs_normalized,
										rhs,
										input,
										proc_node);
					}
					// If not a function call, we use the standard assignment
					// handling routine
					else
					{
						assigned =
							processBasicAssignment(lhs_normalized,
									rhs_normalized,
									stmt,
									input);
					}
					if (output == null)
						output = assigned;
					else
						output = output.union(assigned);
				}
				else if ( IRTools.containsClass(t, FunctionCall.class) )
				{
					Domain ret;
					ret = processFunctionUpdate(proc_node, t);
					if (ret == null)
					{
						output = input.clone();
					}
					else
						output = ret;
				}
				else
				{
					output = input.clone();
				}
				break;
			}
			else if ( IRTools.containsClass(t, FunctionCall.class) )
			{
				Domain ret;
				ret = processFunctionUpdate(proc_node, t);
				if (ret == null)
				{
					output = input.clone();
				}
				else
					output = ret;
				break;
			}
			else
			{
				output = input.clone();
			}
		}

		return output;
	}

	/**
	 * Core handling of pointer assignment. Uses computation of 
	 * LHS location, RHS location. GEN and KILL sets are created 
	 * accordingly for the assignment update, thus providing the 
	 * OUT domain information.
	 * @param lhs Normalized LHS expression in assignment
	 * @param rhs Normalized RHS expression in assignment
	 * @param stmt Parent IR statement 
	 * @param input IN domain
	 * @return output OUT domain
	 */
	protected static Domain processBasicAssignment(
			Expression lhs,
			Expression rhs,
			Statement stmt,
			Domain input)
	{
		Domain output = null;
		boolean points_to_universe = false;

		// Check and handle pointer arithmetic if 
		// present in LHS or RHS
		if (checkPointerArithmetic(lhs)==true)
		{
			lhs = normalizePointerArithmetic(lhs);
			if (lhs == null)
			{
				output = Universe.getUniverse();
				return output;
			}
		}
		if (checkPointerArithmetic(rhs)==true)
		{
			rhs = normalizePointerArithmetic(rhs);
			if (rhs == null)
			{
				output = Universe.getUniverse();
				return output;
			}
		}
		// ----------------------- OBTAIN L-LOCATION SET ------------------------
		// ***x = &y
		// (*x)->y = &z
		// ***x and (*x)->y are expressions corresponding to L-locations
		Map<Symbol, Boolean> l_locations = new HashMap();
		points_to_universe |= computeLlocations(
				l_locations,
				lhs,
				input);

		// ---------------------- DETERMINE TYPE ------------------------------
		// If the l-locations are pointer types, only then proceed with
		// points to analysis, else return input.clone()
		for (Symbol s : l_locations.keySet())
		{
			if (PointsToAnalysis.isPointer(s))
				continue;

			output = input.clone();
			return output;
		}
		if (l_locations.isEmpty() && !points_to_universe)
		{
			output = input.clone();
			return output;
		}

		// ------------------------ OBTAIN L-LOCATION KILL SET --------------------
		Map<Symbol, Boolean> l_locations_kill = new HashMap();
		points_to_universe |= computeLlocationsKill(
				l_locations_kill,
				lhs,
				input);
		// Kill l_locations which eventually have 'definite' locations
		// associated with them
		Set killset = new HashSet();
		for (Symbol s : l_locations_kill.keySet())
		{
			if (l_locations_kill.get(s) == true)
				killset.add(s);
		}
		Domain kill = null;
		if (input instanceof PointsToDomain)
			kill = ((PointsToDomain)input).killSet(killset);
		// input has to be NullDomain in which case kill 
		// information doesn't need to be created
		// provide empty kill domain
		else
			kill = new PointsToDomain();

		// Irrespective of whether input was PointsToDomain or NullDomain,
		// we can't determine what we're assigning to anymore. Hence return output 
		// for this statement as NullDomain
		if (points_to_universe)
		{
			output = Universe.getUniverse();
			return output;
		}

		// ----------------------- OBTAIN THE R-LOCATION SET ---------------------
		// ***x = &y
		// (*x)->y = &z
		// y and z are expressions corresponding to R-locations
		Map<Symbol, Boolean> r_locations = new HashMap();
		points_to_universe |= computeRlocations(
				r_locations,
				rhs,
				stmt,
				input);

		// If we're pointing to universe after failing to determine 
		// r-location, it means we can identify the l-location at 
		// least. Hence kill the relationships for the l-location
		// and return an updated version of the input with the 
		// l-locations killed
		if (points_to_universe)
		{
			output = Universe.getUniverse();
			return output;
		}

		// ------------------------ OBTAIN THE CHANGED INPUT SET ---------------------
		Domain changed_input = null;
		if (input instanceof PointsToDomain)
		{
			PointsToDomain diff_domain = new PointsToDomain();
			PointsToDomain temp_domain = new PointsToDomain();
			for (Symbol pointer : l_locations.keySet())
			{
				if (l_locations.get(pointer) == false)
				{
					HashSet<PointsToRel> rel_set = ((PointsToDomain)input).get(pointer);
					if (rel_set != null)
					{
						for (PointsToRel p_rel : rel_set)
						{
							if (p_rel.isDefinite())
							{
								diff_domain.addRel(p_rel);
								PointsToRel new_rel = p_rel.clone();
								new_rel.setPossible();
								temp_domain.addRel(new_rel);
							}
						}
					}
				}
			}		
			changed_input = temp_domain.union(
					input.diffStrong(diff_domain));
		}
		else
			changed_input = input;

		// -------------------------- OBTAIN THE GEN SET -------------------------
		Domain gen = null;
		if (!(l_locations.isEmpty()) &&
				!(r_locations.isEmpty()))
		{
			// Need to create new points to relationships
			gen = new PointsToDomain();
			for (Symbol pointer : l_locations.keySet())
			{
				for (Symbol pointsto : r_locations.keySet())
				{
					PointsToRel new_rel = new PointsToRel(
							pointer,
							pointsto,
							(l_locations.get(pointer) &&
									r_locations.get(pointsto)));
					((PointsToDomain)gen).addRel(new_rel);
				}
			}
		}
		else if (input instanceof NullDomain ||
				input instanceof Universe)
		{
			gen = input;
		}
		else
			// No gen information for this statement
			gen = new PointsToDomain();

		// ------------------------ OBTAIN THE OUTPUT SET ---------------------
		// OUT = GEN U (IN - KILL)
		output = gen.union(
				changed_input.diffStrong(kill));

		return output;
	}
	
	/*
	 * Handles normalized lhs expressions and uses IN information 
	 * to determine L-locations. Pointer-chains are handled through 
	 * iteration. Arrays are treated conservatively as a single 
	 * location with "P" possible relationship.
	 * 
	 * Returns points_to_universe = TRUE if unable to correctly 
	 * determine l-location information
	 */
	private static boolean computeLlocations(
			Map<Symbol, Boolean> l_locations,
			Expression lhs,
			Domain input)
	{
		boolean lhs_rel = true;
		boolean points_to_universe = false;

		// As we consider the entire array to be a single location, we only use the 
		// name of the array to determine location information
		if (lhs instanceof ArrayAccess)
		{
			lhs = ((ArrayAccess)lhs).getArrayName();
			// Any pointer to the array has a P(possible) relation
			lhs_rel = false;
		}

		Symbol lhs_symbol = exprToLocation(lhs);

		HashMap<Symbol, Boolean> deref_symbols = 
			new HashMap<Symbol, Boolean>();
		if (input instanceof PointsToDomain &&
				lhs instanceof AccessExpression)
		{
			AccessSymbol access_sym = new AccessSymbol((AccessExpression)lhs);
			Map<Symbol, Boolean> l_lhs_locations_search = 
				new HashMap();
			Map<Symbol, Boolean> l_rhs_locations_search =
				new HashMap();
			if (access_sym.getBaseSymbol() instanceof DerefSymbol)
			{
				Expression base_exp = ((AccessExpression)lhs).getLHS();
				points_to_universe |= computeLlocations(
						l_lhs_locations_search,
						base_exp,
						input);
			}
			else
				l_lhs_locations_search.put(access_sym.getBaseSymbol(), true);

			// The RHS of the access expression is always a member field
			// and thus its symbol is used as it is
			l_rhs_locations_search.put(access_sym.getMemberSymbol(), true);

			if ( !points_to_universe)
			{
				for (Symbol base : l_lhs_locations_search.keySet())
				{
					for (Symbol member : l_rhs_locations_search.keySet())
					{
						AccessSymbol actual_struct = new AccessSymbol(base, member);
						l_locations.put(actual_struct,
								(l_lhs_locations_search.get(base) &&
										l_rhs_locations_search.get(member)));
					}
				}
			}
		}
		else if (input instanceof PointsToDomain &&
				lhs instanceof UnaryExpression)
		{
			int depth = 0;
			// If lhs is unary expression, its symbol will be
			// DerefSymbol always
			if (lhs_symbol instanceof DerefSymbol)
			{
				depth = ((DerefSymbol)lhs_symbol).getDepth();
				deref_symbols.put(
						((DerefSymbol)lhs_symbol).getVisibleSymbol(),
						lhs_rel);
			}
			else
			{
				points_to_universe = true;
				PrintTools.println("ERROR: lhs unary expression doesn't give deref symbol", 3);
			}
			while (depth > 0)
			{
				HashSet<PointsToRel> pointed_to = new HashSet<PointsToRel>();
				// For the current set of symbols, get their points to relationships
				for (Symbol s : deref_symbols.keySet())
				{
					// They might not point to anything - INVALID CODE?
					// If they're formal parameters/invisible variables?
					if (((PointsToDomain)input).get(s) != null)
						pointed_to.addAll(((PointsToDomain)input).get(s));
					else if ( (PointsToAnalysis.isPointer(lhs_symbol)) )
					{
						// Be a little more precise than just reassigning to 
						// points to universe
						// Try and check the type of the final lhs_location, 
						// are we actually assigning to a pointer?
						// If it is pointer-type, we are out of luck
						points_to_universe = true;
						break;
					}
				}

				deref_symbols.clear();
				for (PointsToRel p_rel : pointed_to)
				{
					deref_symbols.put(p_rel.getPointedToSymbol(),
							p_rel.isDefinite());
				}

				// if even one symbol in the deref set is not a pointer,
				// we assume we've been doing everything right and that
				// this isn't a pointer assignment statement
				// we've reached the end 
				// of a dereference chain to a variable location
				for (Symbol s : deref_symbols.keySet())
				{
					if ( !(PointsToAnalysis.isPointer(s)) )
					{
						depth = 0;
						break;
					}
				}

				depth--;
			}
			// Add all finally arrived symbols to the l-location set
			l_locations.putAll(deref_symbols);
		}
		// If input is instance of Universe, current points-to 
		// information is pointing to universe
		else if ( (input instanceof Universe) &&
				lhs instanceof UnaryExpression )
		{
			// Leave l_locations empty, there is no strong update
			points_to_universe = true;
		}
		else if ( input instanceof NullDomain )
			l_locations.clear();
		// lhs is not a unary expression of type *x, 
		// just a pointer variable being assigned to
		// This is a strong update to the l-location
		else
		{
			l_locations.put(lhs_symbol, lhs_rel);
		}

		return points_to_universe;
	}

	/*
	 * See computeLlocations(). Special handling needed 
	 * to avoid killing l-location relationships with "P" 
	 * type.
	 */
	private static boolean computeLlocationsKill(
			Map<Symbol, Boolean> l_locations_kill,
			Expression lhs,
			Domain input)
	{	
		boolean lhs_rel = true;
		boolean points_to_universe = false;

		// As we consider the entire array to be a single location, we only use the 
		// name of the array to determine location information
		if (lhs instanceof ArrayAccess)
		{
			lhs = ((ArrayAccess)lhs).getArrayName();
			lhs_rel = false;
		}

		Symbol lhs_symbol = exprToLocation(lhs);

		// For arrays, we consider the whole array to be one single location and hence 
		// any pointer to the array has a P(possible) relation
		//if (SymbolTools.isArray(lhs_symbol))
		//lhs_rel = false;

		Expression lhs_ref;
		HashMap<Symbol, Boolean> kill_symbols = 
			new HashMap<Symbol, Boolean>();
		if (input instanceof PointsToDomain &&
				lhs instanceof AccessExpression)
		{
			AccessSymbol access_sym = new AccessSymbol((AccessExpression)lhs);
			Map<Symbol, Boolean> l_lhs_locations_search = 
				new HashMap();
			Map<Symbol, Boolean> l_rhs_locations_search =
				new HashMap();
			if (access_sym.getBaseSymbol() instanceof DerefSymbol)
			{
				Expression base_exp = ((AccessExpression)lhs).getLHS();
				Expression base_local = base_exp.clone();//normalizePointsTo(base_exp);
				points_to_universe |= computeLlocations(
						l_lhs_locations_search,
						base_exp,
						input);
			}
			else
				l_lhs_locations_search.put(access_sym.getBaseSymbol(), true);

			// The RHS of the access expression is always a member field
			// and thus its symbol is used as it is
			l_rhs_locations_search.put(access_sym.getMemberSymbol(), true);

			if ( !points_to_universe)
			{
				for (Symbol base : l_lhs_locations_search.keySet())
				{
					for (Symbol member : l_rhs_locations_search.keySet())
					{
						AccessSymbol actual_struct = new AccessSymbol(base, member);
						l_locations_kill.put(actual_struct,
								(l_lhs_locations_search.get(base) &&
										l_rhs_locations_search.get(member)));
					}
				}
			}
		}
		else if (input instanceof PointsToDomain &&
				lhs instanceof UnaryExpression)
		{
			int depth = 0;
			if (lhs_symbol instanceof DerefSymbol)
			{
				depth = ((DerefSymbol)lhs_symbol).getDepth();
				kill_symbols.put(
						((DerefSymbol)lhs_symbol).getVisibleSymbol(),
						lhs_rel);
			}
			while (depth > 0)
			{
				HashSet<PointsToRel> pointed_to = new HashSet<PointsToRel>();
				// For the current set of symbols, get their points to relationships
				for (Symbol s : kill_symbols.keySet())
				{
					// They might not point to anything - INVALID CODE?
					// If they're formal parameters/invisible variables?
					if ( kill_symbols.get(s)==true && 
							((PointsToDomain)input).get(s) != null )
						pointed_to.addAll(((PointsToDomain)input).get(s));
					else if ( ((PointsToDomain)input).get(s) == null &&
							(PointsToAnalysis.isPointer(lhs_symbol)) )
					{
						points_to_universe = true;
						break;
					}
				}

				kill_symbols.clear();
				for (PointsToRel p_rel : pointed_to)
				{
					kill_symbols.put(p_rel.getPointedToSymbol(),
							p_rel.isDefinite());
				}

				// if even one symbol in the deref set is not a pointer,
				// we assume we've been doing everything right and that
				// this isn't a pointer assignment statement
				// we've reached the end 
				// of a dereference chain to a variable location
				for (Symbol s : kill_symbols.keySet())
				{
					if ( !(PointsToAnalysis.isPointer(s)) )
					{
						depth = 0;
						break;
					}
				}

				depth--;
			}
			l_locations_kill.putAll(kill_symbols);
		}
		// If input is Universe, and we have a unary expression,
		// we can't have a strong update
		else if ( (input instanceof Universe) &&
				lhs instanceof UnaryExpression )
		{
			points_to_universe = true;
		}
		// lhs is not a unary expression of type *x, 
		// just a pointer variable being assigned to
		// killSet in PointsToDomain will handle this
		else
		{
			l_locations_kill.put(lhs_symbol,
					lhs_rel);
		}

		// Having identified all the symbols to be killed and their 
		// corresponding location relationships, we must now add to the
		// set all invisible symbols whose visible symbol relations are 
		// being killed
		// e.g. {p,*p,D},{*p,j,D}
		// p = &i;
		// {p,i,D} -> *p must be killed as well
		Map<Symbol, Boolean> invisible_locations_kill =
			new HashMap();
		for (Symbol s : l_locations_kill.keySet())
		{
			boolean inv_rel = l_locations_kill.get(s);
			Symbol inv_symbol = s;
			while ( (inv_symbol = DerefSymbol.get(inv_symbol)) != null )
			{
				invisible_locations_kill.put(inv_symbol, inv_rel);
			}
		}
		l_locations_kill.putAll(invisible_locations_kill);

		return points_to_universe;
	}

	/*
	 * Just use the l-location derivation for finding the r-locations
	 * Handle special cases for RHS expressions
	 * - NULL pointer int *x = NULL;
	 * - StringLiterals char *c = "Hello World"
	 * - Standard lib pointers stdout, stdin, stderr
	 * Function calls handled by function update functionality
	 */
	private static boolean computeRlocations(
			Map<Symbol, Boolean> r_locations,
			Expression rhs,
			Statement stmt,
			Domain input)
	{
		boolean points_to_universe = false;
		// ----------------------- NULL POINTER ASSIGNMENT CHECK -----------------
		if (isNullPointer(rhs))
		{
			Expression null_loc = new NameID("nullloc");
			IPPointsToAnalysis.AbstractLocation sym =
				IPPointsToAnalysis.AbstractLocation.getLocation(null_loc);
			//r_locations.clear();
			r_locations.put(sym, true);
		}
		// ----------------------- CHARACTER STRING ASSIGNMENT CHECK -------------
		// ----------------------- OTHER ABSTRACT LOCATION CHECK -----------------
		else if (rhs instanceof StringLiteral ||
				standard_lib_pointers.contains(rhs.toString()))
		{
			IPPointsToAnalysis.AbstractLocation sym =
				IPPointsToAnalysis.AbstractLocation.getLocation(
						rhs,
						stmt);
			r_locations.put(sym, true);
		}
		// ----------------------- UNARY EXPRESSION CHECK -----------------
		else
		{
			Expression unary_ref;
			HashMap<Symbol, Boolean> deref_symbols = 
				new HashMap<Symbol, Boolean>();
			// If address of, then r-location is the symbol itself
			if ( (rhs instanceof UnaryExpression) &&
					(((UnaryExpression)rhs).getOperator() == 
						UnaryOperator.ADDRESS_OF) )
			{
				UnaryExpression unary = (UnaryExpression)rhs;
				unary_ref = unary.getExpression();
			}
			else
				unary_ref = rhs;

			Map<Symbol, Boolean> r_lhs_locations_search = 
				new HashMap();
			Expression unary_ref_local =
				unary_ref.clone();//normalizePointsTo(unary_ref);
			points_to_universe |= computeLlocations(
					r_lhs_locations_search,
					unary_ref,
					input);

			deref_symbols.clear();
			deref_symbols.putAll(r_lhs_locations_search);

			// if not address of operation or not even
			// a unary expression, just identify the 
			// r-location in the same way as l-location and then
			// dereference once more to get the actual r-location
			if ( (input instanceof PointsToDomain) &&
					( !(rhs instanceof UnaryExpression) ||
							!(((UnaryExpression)rhs).getOperator() == 
								UnaryOperator.ADDRESS_OF) ) )
			{
				HashSet<PointsToRel> pointed_to = new HashSet<PointsToRel>();
				HashMap<Symbol, Boolean> possible_heap_symbols = new HashMap();
				// For the current set of symbols, get their points to relationships
				for (Symbol s : deref_symbols.keySet())
				{
					// They might not point to anything - INVALID CODE?
					// If they're formal parameters/invisible variables?
					if (((PointsToDomain)input).get(s) != null)
						pointed_to.addAll(((PointsToDomain)input).get(s));
					else if (s instanceof IPPointsToAnalysis.AbstractLocation)
						;// Do nothing, but don't create universe
					else if (s instanceof AccessSymbol && 
							((AccessSymbol)s).getBaseSymbol() instanceof 
							IPPointsToAnalysis.AbstractLocation)
					{
						possible_heap_symbols.put(((AccessSymbol)s).getBaseSymbol(), false);
					}
					else
						// If null, then points to universe
						points_to_universe = true;
				}
				deref_symbols.clear();
				for (PointsToRel p_rel : pointed_to)
				{
					deref_symbols.put(
							p_rel.getPointedToSymbol(),
							p_rel.isDefinite());
				}
				deref_symbols.putAll(possible_heap_symbols);
			}
			else if ( !(rhs instanceof UnaryExpression) ||
					!(((UnaryExpression)rhs).getOperator() ==
						UnaryOperator.ADDRESS_OF) )
			{
				// We have a case where we need to dereference the rhs further,
				// but input isn't PointsToDomain
				points_to_universe = true;
			}

			// Add all finally arrived symbols to the r-location set
			r_locations.putAll(deref_symbols);
		}

		return points_to_universe;
	}

	/*
	 * This provides data flow update to points-to information 
	 * after calling a function. Points-to information may be 
	 * updated for parameters passed into the function or for global
	 * variables. 
	 * See processFunctionAssignment for returned pointer values. 
	 * Consequently, points-to information must be generated or updated
	 */
	private static Domain processFunctionUpdate(
			IPANode proc_node,
			Traversable t)
	{
		Domain update = null;

		// Find all function calls in this statement and process
		// them in semantic order
		LinkedList<FunctionCall> calls = new LinkedList();
		DepthFirstIterator iter = new DepthFirstIterator(t);
		while (iter.hasNext())
		{
			Object o = iter.next();
			if (o instanceof FunctionCall)
			{
				// Found function call, add it to the front of the list
				calls.addFirst((FunctionCall)o);
			}
		}

		// if proc_node is null, we're performing intra analysis and hence
		// a function call must be handled conservatively and the 
		// return information must be points to universe
		if (proc_node == null)
		{
			return (Universe.getUniverse());
		}

		while (!calls.isEmpty())
		{
			FunctionCall call = calls.remove();
			CallSite callsite = proc_node.getCallSite(call);
			Domain call_result = null;
			if (StandardLibrary.contains(call))
				return null;
			else if (IPPointsToAnalysis.isSafeLibraryCall(call))
				return null;
			// User library call
			else if (callsite.getCallee() == null)
				return (Universe.getUniverse());
			else
				call_result = callsite.out();

			if (update == null)
			{
				update = call_result.clone();
			}
			else
				update = update.union(call_result);
		}

		return update;
	}

	/*
	 * Handles functions that return pointer values i.e. 
	 * those appearing in pointer assignment expressions
	 */
	private static Domain processFunctionAssignment(
			Expression lhs,
			Expression rhs,
			Domain input,
			IPANode proc_node)
	{
		Domain output;
		Domain update = processFunctionUpdate(proc_node, (Traversable)rhs);
		if (update != null)
			input = update;

		boolean points_to_universe = false;
		// ----------------------- OBTAIN L-LOCATION SET ------------------------
		// ***x = &y
		// (*x)->y = &z
		Map<Symbol, Boolean> l_locations = new HashMap();
		points_to_universe |= computeLlocations(
				l_locations,
				lhs,
				input);

		// ---------------------- DETERMINE TYPE ------------------------------
		// If the l-locations are pointer types, only then proceed with
		// points to analysis, else return input.clone()
		for (Symbol s : l_locations.keySet())
		{
			if (PointsToAnalysis.isPointer(s))
				continue;

			output = input.clone();
			return output;
		}
		if (l_locations.isEmpty() && !points_to_universe)
		{
			output = input.clone();
			return output;
		}

		// ------------------------ OBTAIN L-LOCATION KILL SET --------------------
		Map<Symbol, Boolean> l_locations_kill = new HashMap();
		points_to_universe |= computeLlocationsKill(
				l_locations_kill,
				lhs,
				input);
		// Kill l_locations which eventually have 'definite' locations
		// associated with them
		Set killset = new HashSet();
		for (Symbol s : l_locations_kill.keySet())
		{
			if (l_locations_kill.get(s) == true)
				killset.add(s);
		}
		Domain kill = null;
		if (input instanceof PointsToDomain)
			kill = ((PointsToDomain)input).killSet(killset);
		// input has to be NullDomain in which case kill 
		// information doesn't need to be created
		// provide empty kill domain
		else
			kill = new PointsToDomain();

		// Irrespective of whether input was PointsToDomain or NullDomain,
		// we can't determine what we're assigning to anymore. Hence return output 
		// for this statement as NullDomain
		if (points_to_universe)
		{
			output = Universe.getUniverse();
			return output;
		}

		// ----------------------- OBTAIN THE R-LOCATION SET ---------------------	
		// Get the outermost function call in the rhs, this is the call site that 
		// returns the value being assigned to the lhs
		DepthFirstIterator dfs_iter = new DepthFirstIterator(rhs);
		FunctionCall call = null;
		while (dfs_iter.hasNext())
		{
			Object o = dfs_iter.next();
			if (o instanceof FunctionCall)
			{
				call = (FunctionCall)o;
				break;
			}
		}
		Map<Symbol, Boolean> r_locations = new HashMap();
		Set<PointsToRel> return_result = null;
		return_result = IPPointsToAnalysis.getReturnRelations(
				proc_node.getCallSite(call));
		for (PointsToRel p_rel : return_result)
			r_locations.put(p_rel.getPointedToSymbol(),
					p_rel.isDefinite());


		// If we're pointing to universe after failing to determine 
		// r-location, it means we can identify the l-location at 
		// least. Hence kill the relationships for the l-location
		// and return an updated version of the input with the 
		// l-locations killed
		if (points_to_universe)
		{
			output = Universe.getUniverse();
			return output;
		}

		// ------------------------ OBTAIN THE CHANGED INPUT SET ---------------------
		Domain changed_input = null;
		if (input instanceof PointsToDomain)
		{
			PointsToDomain diff_domain = new PointsToDomain();
			PointsToDomain temp_domain = new PointsToDomain();
			for (Symbol pointer : l_locations.keySet())
			{
				if (l_locations.get(pointer) == false)
				{
					HashSet<PointsToRel> rel_set = ((PointsToDomain)input).get(pointer);
					if (rel_set != null)
					{
						for (PointsToRel p_rel : rel_set)
						{
							if (p_rel.isDefinite())
							{
								diff_domain.addRel(p_rel);
								PointsToRel new_rel = p_rel.clone();
								new_rel.setPossible();
								temp_domain.addRel(new_rel);
							}
						}
					}
				}
			}		
			changed_input = temp_domain.union(
					input.diffStrong(diff_domain));
		}
		else
			changed_input = input;

		// -------------------------- OBTAIN THE GEN SET -------------------------
		Domain gen = null;
		if (!(l_locations.isEmpty()) &&
				!(r_locations.isEmpty()))
		{
			// Need to create new points to relationships
			gen = new PointsToDomain();
			for (Symbol pointer : l_locations.keySet())
			{
				for (Symbol pointsto : r_locations.keySet())
				{
					PointsToRel new_rel = new PointsToRel(
							pointer,
							pointsto,
							(l_locations.get(pointer) &&
									r_locations.get(pointsto)));
					((PointsToDomain)gen).addRel(new_rel);
				}
			}
		}
		else if (input instanceof NullDomain ||
				input instanceof Universe)
		{
			gen = input;
		}
		else
			// No gen information for this statement
			gen = new PointsToDomain();

		// ------------------------ OBTAIN THE OUTPUT SET ---------------------
		output = gen.union(
				changed_input.diffStrong(kill));

		return output;
	}

	/**
	 * In order to simplify points to analysis, normalize the expression
	 * that might include pointers, dereferences, access expressions etc.
	 * @param e The expression to be normalized
	 * @return Expression with same symbols, but in normalized form
	 */
	protected static Expression normalizePointsTo(Expression e)
	{
		Expression e_clone = e.clone();
		Expression normalized = null;
		Map<Expression, Expression> swap_pairs = new HashMap();
		DepthFirstIterator iter = new DepthFirstIterator(e);
		iter.pruneOn(AccessExpression.class);
		iter.pruneOn(ArrayAccess.class);

		while (iter.hasNext())
		{
			Object o = iter.next();

			if (o instanceof AccessExpression)
			{
				AccessExpression access = (AccessExpression)o;
				Expression lhs = normalizePointsTo(
						access.getLHS());
				Expression rhs = normalizePointsTo(
						access.getRHS());
				lhs.setParens(true);
				rhs.setParens(true);
				// Examples
				// (x).y
				// (*x).y
				// Examples
				// (x).(*y)
				if (access.getOperator() == AccessOperator.MEMBER_ACCESS)
				{
					// Intermediate normalization step where we end up with
					// x.(&y[0])
					// This should be
					// &(x.y[0])
					if ( (rhs instanceof UnaryExpression) &&
							((UnaryExpression)rhs).getOperator() == UnaryOperator.ADDRESS_OF )
					{
						Expression acc;
						rhs = ((UnaryExpression)rhs).getExpression();
						if (rhs instanceof ArrayAccess)
						{
							Expression normalized_name = 
								normalizePointsTo(((ArrayAccess)rhs).getArrayName());
							List<Expression> indices = ((ArrayAccess)rhs).getIndices();
							List<Expression> normalized_indices = new LinkedList();
							for (Expression index : indices)
								normalized_indices.add(normalizePointsTo(index));
							
							normalized_name = new AccessExpression(
									lhs,
									AccessOperator.MEMBER_ACCESS,
									normalized_name);
							acc = new ArrayAccess(
									normalized_name,
									normalized_indices); 
							
						}
						else
						{
							acc = new AccessExpression(
									lhs,
									AccessOperator.MEMBER_ACCESS,
									rhs);
						}
						acc.setParens(true);
						normalized = new UnaryExpression(
								UnaryOperator.ADDRESS_OF,
								acc);
					}
					else
					{
						normalized = new AccessExpression(
								lhs,
								AccessOperator.MEMBER_ACCESS,
								rhs);
					}
				}
				else if (access.getOperator() == AccessOperator.MEMBER_DEREF_ACCESS)
				{
					UnaryExpression unary_rhs = new UnaryExpression(
							UnaryOperator.DEREFERENCE,
							rhs);
					normalized = new AccessExpression(
							lhs,
							AccessOperator.MEMBER_ACCESS,
							unary_rhs);
				}
				// Examples
				// (x->)y
				// (*x)->(y)
				else if (access.getOperator() == AccessOperator.POINTER_ACCESS)
				{
					UnaryExpression unary_lhs = new UnaryExpression(
							UnaryOperator.DEREFERENCE,
							lhs);
					normalized = new AccessExpression(unary_lhs,
							AccessOperator.MEMBER_ACCESS,
							rhs);
				}
				// Examples
				// (x->*)y
				else if (access.getOperator() == AccessOperator.POINTER_MEMBER_ACCESS)
				{
					UnaryExpression unary_lhs = new UnaryExpression(
							UnaryOperator.DEREFERENCE,
							lhs);
					UnaryExpression unary_rhs = new UnaryExpression(
							UnaryOperator.DEREFERENCE,
							rhs);
					normalized = new AccessExpression(
							unary_lhs,
							AccessOperator.MEMBER_ACCESS,
							unary_rhs);
				}
				normalized.setParens(true);
				swap_pairs.put(access, normalized);
			}
			else if (o instanceof ArrayAccess)
			{
				Expression name = ((ArrayAccess)o).getArrayName();
				// If the variable being used as an array has not been
				// declared an array, it must be a pointer to an array
				// If its name isn't already being dereferenced, create
				// a normalized array access operation
				if ( ( !(SymbolTools.isArray(SymbolTools.getSymbolOf(name))) ||
						(SymbolTools.isFormal(SymbolTools.getSymbolOf(name))) ) &&
						!(name instanceof UnaryExpression))
				{
					// This is an array access via a pointer 
					// pointing to that array
					// convert from pointer[i] to (*pointer)[i]
					Expression normalized_name = normalizePointsTo(name);
					List<Expression> indices = ((ArrayAccess)o).getIndices();
					List<Expression> normalized_indices = new LinkedList();
					for (Expression index : indices)
						normalized_indices.add(normalizePointsTo(index));

					Expression new_name = normalized_name;
					for (int i = normalized_indices.size(); i > 0; i--)
					{
						new_name = new UnaryExpression(
								UnaryOperator.DEREFERENCE,
								new_name);
					}
					new_name.setParens(true);
					normalized = new ArrayAccess(
							new_name,
							normalized_indices);
				}
				else
					normalized = ((ArrayAccess)o).clone();
				// Now, if this array access is not through 
				// a pointer variable
				if ( SymbolTools.isArray(SymbolTools.getSymbolOf(name)) )
				{
					// If the expression is an array access such that it 
					// represents a sub-array pointer, normalize it
					// e.g.
					// int z[5][5], *y;
					// y = z[4];
					// The actual semantics of this assignment are:
					// y = &(z[4][0]);
					int dimensions = 0;;
					List<ArraySpecifier> array_specs =
						(SymbolTools.getSymbolOf(name)).getArraySpecifiers();
					// Adding up dimensions for all trailing array specs
					// TODO:
					// Check when the list of array specifiers is 
					// greater than size=1
					for (ArraySpecifier aspec : array_specs)
						dimensions += aspec.getNumDimensions();
					// If the array access contains less dimensions than the 
					// declaration, it means we're looking at a pointer that 
					// points inside the array aggregate structure
					if ( ((ArrayAccess)o).getNumIndices() < dimensions )
					{
						ArrayAccess a = ((ArrayAccess)normalized).clone();
						a.addIndex(new IntegerLiteral(0));
						normalized = new UnaryExpression(
								UnaryOperator.ADDRESS_OF,
								a);
					}
				}
				swap_pairs.put((ArrayAccess)o, normalized);
			}
			else if (o instanceof Identifier)
			{
				if ( SymbolTools.isArray(SymbolTools.getSymbolOf((Identifier)o)) )
				{
					Object parent = ((Identifier)o).getParent();
					if ( !(parent instanceof ArrayAccess ) )
					{
						ArrayAccess a = new ArrayAccess(
								((Identifier)o).clone(),
								new IntegerLiteral(0));
						normalized = new UnaryExpression(
								UnaryOperator.ADDRESS_OF,
								a);
						swap_pairs.put((Identifier)o, normalized);
					}
				}
			}
		}
		for (Expression expr : swap_pairs.keySet())
		{
			List<Expression> cloned_substitutes = e_clone.findExpression(expr);
			// We substitute only the first occurrence with the normalized version
			// as others will be found subsequently
			Expression expr_clone = 
				((LinkedList<Expression>)cloned_substitutes).getFirst();
			// This is e_clone itself, or else it would be traversable 
			// upward
			if (expr_clone.getParent() == null)
				e_clone = swap_pairs.get(expr);
			else
				expr_clone.swapWith(swap_pairs.get(expr));
		}

		return e_clone;
	}

	/**
	 * Use this to annotate a traversable object with the statement-based
	 * points-to relationships identified inside the traversable
	 * Annotations are inserted as comments before each statement
	 * @param t The traversable to annotate
	 * @param pointsto Map from statement to its domain (relationships)
	 */
	protected static void annotatePointsTo(Traversable t,
			Map pointsto)
	{
		DepthFirstIterator iter = new DepthFirstIterator(t);
		while (iter.hasNext())
		{
			Object o = iter.next();
			if (o instanceof Statement)
			{
				Domain domain = (Domain)
				pointsto.get((Statement)o);
				if (domain != null)
				{
					String annot_string = "";
					annot_string += domain.toString();
					if (!annot_string.equals(""))
					{
						CommentAnnotation annot = new CommentAnnotation(
								annot_string);
						((Statement)o).annotateBefore(annot);
					}
				}
			}
		}
	}

	private static boolean checkPointerArithmetic(Traversable t)
	{
		boolean pointer_arithmetic = false;

		// Binary operators that can provide address calculation
		// are also considered as pointer arithmetic if one of the
		// operands is a pointer
		// e.g. (a+b)->x
		// Here (a+b) result in a new address value that 
		// supposedly points somewhere into a struct to member x
		Set<BinaryOperator> binary_ops = new HashSet(Arrays.asList(
				BinaryOperator.ADD, BinaryOperator.SUBTRACT, 
				BinaryOperator.BITWISE_AND, BinaryOperator.BITWISE_EXCLUSIVE_OR,
				BinaryOperator.BITWISE_INCLUSIVE_OR, BinaryOperator.DIVIDE,
				BinaryOperator.MODULUS, BinaryOperator.MULTIPLY,
				BinaryOperator.SHIFT_LEFT, BinaryOperator.SHIFT_RIGHT
		));

		DepthFirstIterator iter = new DepthFirstIterator(t);
		while (iter.hasNext())
		{
			Object o = iter.next();
			if (o instanceof UnaryExpression)
			{
				UnaryExpression u = (UnaryExpression)normalizePointsTo((Expression)o);
				if (UnaryOperator.hasSideEffects(u.getOperator()))
				{
					Expression e = u;
					while ( e instanceof UnaryExpression &&
							UnaryOperator.hasSideEffects(
									((UnaryExpression)e).getOperator()) )
					{
						e = ((UnaryExpression)e).getExpression();
					}
					if (isPointer(exprToLocation(e)))
					{
						pointer_arithmetic = true;
						break;
					}
				}
			}
			else if (o instanceof BinaryExpression)
			{
				BinaryOperator op = ((BinaryExpression)o).getOperator();

				if (binary_ops.contains(op))
				{
					Expression elhs = 
						normalizePointsTo(((BinaryExpression)o).getLHS());
					Expression erhs = 
						normalizePointsTo(((BinaryExpression)o).getRHS());

					if (elhs instanceof Typecast)
					{
						List children = ((Typecast)elhs).getChildren();
						if (children.size() == 1)
							elhs = (Expression)children.get(0);
						else
							continue;
					}
					if (erhs instanceof Typecast)
					{
						List children = ((Typecast)erhs).getChildren();
						if (children.size() == 1)
							erhs = (Expression)children.get(0);
						else
							continue;
					}

					Symbol lhs = exprToLocation(elhs);
					Symbol rhs = exprToLocation(erhs);
					if ( (isPointer(lhs) && 
							(SymbolTools.isInteger(rhs) || erhs instanceof IntegerLiteral)) || 
							(isPointer(rhs) && 
								(SymbolTools.isInteger(lhs) || elhs instanceof IntegerLiteral)) )						
					{
						// This means there's some computation going on
						// involving pointers
						pointer_arithmetic = true;
						break;
					}
					else if (elhs instanceof UnaryExpression &&
							((UnaryExpression)elhs).getOperator()==UnaryOperator.ADDRESS_OF)
					{
						if (erhs instanceof IntegerLiteral ||
								SymbolTools.isInteger(rhs))
						{
							pointer_arithmetic = true;
							break;
						}
					}
					else if (erhs instanceof UnaryExpression &&
							((UnaryExpression)erhs).getOperator()==UnaryOperator.ADDRESS_OF)
					{
						if (elhs instanceof IntegerLiteral ||
								SymbolTools.isInteger(lhs))
						{
							pointer_arithmetic = true;
							break;
						}						
					}
				}
			}
		}
		return pointer_arithmetic;
	}

	// Handles pointer initialization at the start of 
	// entering a new scope
	private static Domain enterScope(DFANode node,
			Domain input,
			IPANode proc_node,
			Map stmt_domain)
	{
		boolean points_to_universe = false;
		Domain out_domain = null;
		Domain in_domain = null;
		in_domain = input.clone();

		SymbolTable symtab = node.getData("symbol-entry");
		if (symtab == null)
			return out_domain;
		else if (symtab instanceof CompoundStatement ||
				symtab instanceof Procedure  ||
				symtab instanceof TranslationUnit)
		{
			DepthFirstIterator iter = new DepthFirstIterator((Traversable)symtab);
			while (iter.hasNext())
			{
				Object o = iter.next();
				if ( o instanceof DeclarationStatement)
				{
					stmt_domain.put((DeclarationStatement)o, in_domain);
					continue;
				}
					
				if ( !(o instanceof Symbol) )
					continue;

				Symbol s = (Symbol)o;
				if ( !(s instanceof VariableDeclarator) )
					continue;

				Initializer init = ((VariableDeclarator)s).getInitializer();
				if (init != null)
				{
					Statement enclosing_stmt = IRTools.getAncestorOfType(init,
							Statement.class);
					Symbol lhs_symbol = s;
					List<Traversable> init_vals = init.getChildren();

					if (SymbolTools.isPointer(lhs_symbol))
					{
						Domain gen = new PointsToDomain();
						for (int i = (init_vals.size()-1); i>=0; i--)
						{
							Traversable t = init_vals.get(i);
							if (t instanceof Expression)
							{
								Expression rhs = (Expression)t;
								Expression rhs_local = normalizePointsTo(rhs);

								if ( IRTools.containsClass((Traversable)rhs, FunctionCall.class) )
								{
									if (proc_node != null)
									{
										// ----------------------- OBTAIN THE R-LOCATION SET ---------------------	
										// Get the outermost function call in the rhs, this is the call site that 
										// returns the value being assigned to the lhs
										DepthFirstIterator dfs_iter = new DepthFirstIterator(rhs);
										FunctionCall call = null;
										while (dfs_iter.hasNext())
										{
											Object obj = dfs_iter.next();
											if (obj instanceof FunctionCall)
											{
												call = (FunctionCall)obj;
												break;
											}
										}
										Map<Symbol, Boolean> r_locations = new HashMap();
										Set<PointsToRel> return_result = null;
										return_result = IPPointsToAnalysis.getReturnRelations(
												proc_node.getCallSite(call));
										for (PointsToRel p_rel : return_result)
											r_locations.put(p_rel.getPointedToSymbol(),
													p_rel.isDefinite());

										PointsToDomain init_domain = new PointsToDomain();
										for (Symbol rhs_symbol : r_locations.keySet())
										{
											PointsToRel p_rel = new PointsToRel(
													lhs_symbol,
													rhs_symbol,
													r_locations.get(rhs_symbol));
											init_domain.addRel(p_rel);
										}
										gen = gen.union(init_domain);
									}
									else
									{
										gen = Universe.getUniverse();
									}
								}
								else
								{
									// Now compute the r-location set
									Map<Symbol, Boolean> r_locations = new HashMap();
									points_to_universe |= computeRlocations(
											r_locations,
											rhs_local,
											enclosing_stmt,
											in_domain);

									if (points_to_universe)
									{
										gen = Universe.getUniverse();
									}
									// We must generate points to information
									else
									{
										PointsToDomain init_domain = new PointsToDomain();
										for (Symbol rhs_symbol : r_locations.keySet())
										{
											PointsToRel p_rel = new PointsToRel(
													lhs_symbol,
													rhs_symbol,
													r_locations.get(rhs_symbol));
											init_domain.addRel(p_rel);
										}
										gen = gen.union(init_domain);
									}
								}
							}
							else
							{
								gen = Universe.getUniverse();
							}
						}
						out_domain = gen.union(in_domain);
					}
					else
					{
						// Not even a pointer symbol, output 
						// is same as input
						out_domain = in_domain.clone();
					}
				}
				else
				{
					out_domain = in_domain.clone();
				}

				// For the next symbol/declaration/initializer, the in_domain
				// must be the current out_domain
				in_domain = out_domain.clone();
			}
		}

		return out_domain;
	}

	/**
	 * Returns the abstract stack location associated with the given expression.
	 * Notice that this method returns null if the given expression does not
	 * represent an abstract stack location, e.g., +e, !e, ...,.
	 */
	protected static Symbol exprToLocation(Expression e)
	{
		Symbol ret = null;
		if ( e instanceof Identifier )
			ret = ((Identifier)e).getSymbol();
		else if ( e instanceof ArrayAccess )
			ret = exprToLocation(((ArrayAccess)e).getArrayName());
		else if ( e instanceof AccessExpression )
			ret = new AccessSymbol((AccessExpression)e);
		else if ( e instanceof UnaryExpression )
		{
			UnaryOperator uop = ((UnaryExpression)e).getOperator();
			Expression expr = ((UnaryExpression)e).getExpression();
			if ( uop == UnaryOperator.DEREFERENCE )
			{
				ret = exprToLocation(expr);
				if ( ret != null )
					ret = DerefSymbol.get(ret);
			}
			else if ( uop == UnaryOperator.POST_DECREMENT ||
					uop == UnaryOperator.POST_INCREMENT ||
					uop == UnaryOperator.PRE_DECREMENT ||
					uop == UnaryOperator.PRE_INCREMENT )
				ret = exprToLocation(expr);
		}
		else if ( e instanceof Literal )
			return null;
		if ( ret == null )
			PrintTools.printlnStatus("[WARNING] "+ e + "does not have a location", 0);
		return ret;
	}

	/**
	 * This functionality is specifically provided separately from 
	 * SymbolTools functionality. We consider variables types for 
	 * Points-To analysis related symbols such as Deref Symbols 
	 * as also Abstract Locations, thus providing accurate 
	 * information to the analyzer. Use only if dealing with these 
	 * constructs.
	 * @param symbol
	 * @return TRUE if the symbol represents a pointer location
	 */
	protected static boolean isPointer(Symbol symbol)
	{
		if ( symbol == null )
			return false;

		List specs = IPPointsToAnalysis.getTypeSpecifiers(symbol);

		if ( specs == null )
			return false;

		for ( Object o : specs )
			if ( o instanceof PointerSpecifier )
				return true;

		return false;
	}

	private static boolean isNullPointer(Expression e)
	{
		boolean ret = false;

		if (e instanceof IntegerLiteral &&
				((IntegerLiteral)e).getValue()==0)
			ret = true;
		else if (e instanceof Identifier &&
				(((Identifier)e).getName()).equals("NULL"))
			ret = true;
		else if (e instanceof Typecast)
		{
			List<Specifier> specs = SymbolTools.getExpressionType(e);
			if ( specs.contains(Specifier.VOID) && 
					specs.contains(PointerSpecifier.UNQUALIFIED) )
			{
				List exprs = ((Typecast)e).getChildren();
				if (exprs.size() == 1)
				{
					Expression child = (Expression)exprs.get(0);
					if ( child instanceof IntegerLiteral &&
							((IntegerLiteral)child).getValue()==0 )
						// ((void *)0)
						ret = true;
				}
			}
		}
		return ret;
	}
	
	/**
	 * Attemps to convert pointer arithmetic expression into an array access
	 * if possible. Currently handles simple binary expressions that involve 
	 * a pointer and an integer value
	 * Returns null if unable to handle other cases
	 * @param e the input expression.
	 * @return the converted expression or null.
	 */
	protected static Expression normalizePointerArithmetic(Expression e)
	{
		Expression e_clone = null;
		// Convert:
		// p++ -> p = &(p[1]);
		// p+=3 -> p = &(p[3]);
		// p = a+10 -> p = &(a[10]);
		
		if (e instanceof UnaryExpression)
		{
			return null;
		}
		else if (e instanceof BinaryExpression)
		{
			BinaryExpression binary = (BinaryExpression)e;
			Expression pointer_expr = null;
			Expression int_literal = null;
			if (binary.getLHS() instanceof IntegerLiteral ||
					SymbolTools.isInteger(SymbolTools.getSymbolOf((binary.getLHS()))))
			{
				int_literal = binary.getLHS().clone();
				pointer_expr = binary.getRHS().clone();
			}
			else if (binary.getRHS() instanceof IntegerLiteral ||
					SymbolTools.isInteger(SymbolTools.getSymbolOf((binary.getRHS()))))
			{
				pointer_expr = binary.getLHS().clone();
				int_literal = binary.getRHS().clone();
			}
			else
				return null;

			if (binary.getOperator() == BinaryOperator.SUBTRACT)
			{
				if (int_literal instanceof IntegerLiteral)
					((IntegerLiteral)int_literal).setValue(
						((IntegerLiteral)int_literal).getValue()*(-1));
				else
					int_literal = new UnaryExpression(
							UnaryOperator.MINUS,
							int_literal);
			}
			else if (binary.getOperator() == BinaryOperator.ADD)
				;
			else
				return null;
			
			Expression unary = null;
			if (IRTools.containsClass(pointer_expr, ArrayAccess.class))
			{
				Expression normalized_expr = pointer_expr.clone();
				DepthFirstIterator arrayaccess_iter = new 
					DepthFirstIterator(normalized_expr);
				arrayaccess_iter.pruneOn(ArrayAccess.class);
				while (arrayaccess_iter.hasNext())
				{
					Object o = arrayaccess_iter.next();
					if ( !(o instanceof ArrayAccess) )
						continue;
					
					ArrayAccess acc = (ArrayAccess)o;
					Expression last_index = acc.getIndex(acc.getNumIndices()-1);
					Expression new_last_index = new BinaryExpression(
							last_index.clone(),
							binary.getOperator(),
							int_literal);
					acc.setIndex(acc.getNumIndices()-1, new_last_index);
					
					unary = normalized_expr;
					break;
				}
			}
			else
			{
				ArrayAccess new_acc = new ArrayAccess(
						pointer_expr,
						int_literal);
				unary = new UnaryExpression(
						UnaryOperator.ADDRESS_OF,
						new_acc);
			}
			e_clone = unary;
		}
		else
			return null;
		
		return e_clone;
	}
	
	/**
	 * API to create a map from Statement to Domain where 
	 * every statement is assigned the value of 
	 * Universe Domain.
	 * @param t The traversable inside of which this assignment
	 * 				must happen
	 * @return The universe map 
	 */
	protected static Map createUniverseMap(Traversable t)
	{
		DepthFirstIterator iter = new DepthFirstIterator(t);
		Domain universe = Universe.getUniverse();
		Map universe_map = new HashMap();
		
		while (iter.hasNext())
		{
			Object o = iter.next();
			if (o instanceof Statement)
			{
				universe_map.put((Statement)o, universe);
			}
		}
		
		return universe_map;
	}
}
