package ch.unibas.cs.hpwc.patus.autotuner;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

import ch.unibas.cs.hpwc.patus.util.StringUtil;

/**
 * Reads performance results generated by jobs submitted by the <code>scripts/autotune.sh</code> script.
 * @author Matthias-M. Christen
 */
public class ReadQsubResults
{
	///////////////////////////////////////////////////////////////////
	// Constants

	private final static Logger LOGGER = Logger.getLogger (ReadQsubResults.class);

	private final static Pattern PATTERN_KEYVALUE = Pattern.compile ("^(((.*):)?)\\s*([0-9\\.eE]+)");

	private final static Pattern PATTERN_CONFIG = Pattern.compile ("(\\d+\\s+)*\\s*");


	///////////////////////////////////////////////////////////////////
	// Inner Types

	private static class Data
	{
		// maps directories to (maps num threads to (maps keys to values))
		private Map<String, Map<Integer, Map<String, Double>>> m_map;

		private List<String> m_listDirectories;
		private Set<Integer> m_setNumThreads;
		private Set<String> m_setKeys;

		public Data ()
		{
			m_map = new HashMap<String, Map<Integer,Map<String,Double>>> ();

			m_listDirectories = new ArrayList<String> ();
			m_setNumThreads = new TreeSet<Integer> ();
			m_setKeys = new TreeSet<String> ();
		}

		public void setEntry (String strDirectory, int nNumThreads, String strKey, double fValue)
		{
			Map<Integer, Map<String, Double>> map1 = m_map.get (strDirectory);
			if (map1 == null)
				m_map.put (strDirectory, map1 = new HashMap<Integer, Map<String,Double>> ());
			Map<String, Double> map2 = map1.get (nNumThreads);
			if (map2 == null)
				map1.put (nNumThreads, map2 = new HashMap<String, Double> ());
			map2.put (strKey, fValue);

			if (!m_listDirectories.contains (strDirectory))
				m_listDirectories.add (strDirectory);
			m_setNumThreads.add (nNumThreads);
			m_setKeys.add (strKey);
		}

		public Iterable<String> getDirectories ()
		{
			return m_listDirectories;
		}

		public Iterable<Integer> getNumThreads ()
		{
			return m_setNumThreads;
		}

		public Iterable<String> getKeys ()
		{
			return m_setKeys;
		}

		public double getValue (String strDirectory, int nNumThreads, String strKey)
		{
			Map<Integer, Map<String, Double>> map1 = m_map.get (strDirectory);
			if (map1 == null)
				return 0;
			Map<String, Double> map2 = map1.get (nNumThreads);
			if (map2 == null)
				return 0;
			Double fValue = map2.get (strKey);
			return fValue == null ? 0 : fValue;
		}
	}


	///////////////////////////////////////////////////////////////////
	// Member Variables

	private String[] m_rgDirectories;

	private Data m_data;

	private Matcher m_matcherConfig;


	///////////////////////////////////////////////////////////////////
	// Implementation

	public ReadQsubResults (String[] rgDirectories)
	{
		m_rgDirectories = rgDirectories;
		m_data = new Data ();
		m_matcherConfig = null;
	}

	public void process ()
	{
		// parse input files
		for (String strDir : m_rgDirectories)
			processDirectory (new File (strDir));

		writeOutput ();
	}

	/**
	 * Processes the directory <code>fileDir</code>.
	 * @param fileDir The directory to process
	 */
	private void processDirectory (File fileDir)
	{
		// sanity checks
		if (fileDir == null)
		{
			ReadQsubResults.LOGGER.info ("Skipping null directory");
			return;
		}

		if (!fileDir.isDirectory ())
		{
			ReadQsubResults.LOGGER.info (StringUtil.concat ("Skipping ", fileDir.getAbsolutePath (), " (is not a directory)"));
			return;
		}

		// find the thread directories
		for (File f : fileDir.listFiles ())
			if (f.isDirectory () && f.getName ().startsWith ("thd"))
				processThreadDirectoy (f);
	}

	private void processThreadDirectoy (File fileDir)
	{
		int nNumThreads = Integer.parseInt (fileDir.getName ().substring ("thd".length ()));

		// read the result.txt file and the result_<params>...txt file corresponding to the best result
		String strLineConfig = null;
		String strLineTicks = null;
		try
		{
			BufferedReader inResult = new BufferedReader (new FileReader (new File (fileDir, "result.txt")));
			for (String strLine = null; ; )
			{
				strLine = inResult.readLine ();
				if (strLine == null)
					break;

				strLineConfig = strLineTicks;
				strLineTicks = strLine;
			}
		}
		catch (FileNotFoundException e)
		{
			ReadQsubResults.LOGGER.error (e.getMessage ());
		}
		catch (IOException e)
		{
		}

		// make sure the config and timings have been found
		if (strLineConfig == null || strLineTicks == null)
		{
			ReadQsubResults.LOGGER.info ("No configuration or timings found");
			return;
		}

		ReadQsubResults.LOGGER.info (strLineTicks);

		// make sure the configuration has the correct format (or it probably isn't the configuration...)
		if (m_matcherConfig == null)
			m_matcherConfig = PATTERN_CONFIG.matcher (strLineConfig);
		else
			m_matcherConfig.reset (strLineConfig);

		if (!m_matcherConfig.matches ())
		{
			LOGGER.error (StringUtil.concat ("Not a valid configuration in file ", fileDir.getAbsolutePath (), "/result.txt: ", strLineConfig));
			return;
		}

		// build the name of the detail result file and process it
		try
		{
			processDetailResultFile (new File (fileDir, StringUtil.concat ("result_", strLineConfig.trim ().replace (' ', '-'), "__", nNumThreads, ".txt")), fileDir, nNumThreads);
		}
		catch (IOException e)
		{
			ReadQsubResults.LOGGER.error (e.getMessage ());
		}
	}

	/**
	 *
	 * @param f
	 * @throws IOException
	 */
	private void processDetailResultFile (File f, File fileThreadDirectory, int nNumThreads) throws IOException
	{
		LOGGER.info (StringUtil.concat ("Reading detail file ", f.getAbsolutePath ()));

		BufferedReader in = new BufferedReader (new FileReader (f));
		Matcher m = null;

		int i = 0;
		for (String strLine = null; ; )
		{
			strLine = in.readLine ();
			if (strLine == null)
				break;

			if (m == null)
				m = ReadQsubResults.PATTERN_KEYVALUE.matcher (strLine);
			else
				m.reset (strLine);

			if (m.find ())
			{
				String strKey = m.group (3);
				double fValue = Double.parseDouble (m.group (4));

				if (strKey == null)
				{
					strKey = StringUtil.concat ("default", i);
					i++;
				}

				m_data.setEntry (fileThreadDirectory.getParentFile ().getName (), nNumThreads, strKey, fValue);
			}
		}
		in.close ();
	}

	/**
	 * Write the output files.
	 */
	private void writeOutput ()
	{
		for (String strKey : m_data.getKeys ())
		{
			try
			{
				PrintWriter out = new PrintWriter (new File (StringUtil.concat (strKey, ".txt")));

				for (String strDirectory : m_data.getDirectories ())
				{
					out.print ('\t');
					out.print (strDirectory);
				}
				out.println ();

				for (int nNumThreads : m_data.getNumThreads ())
				{
					out.print (nNumThreads);

					for (String strDirectory : m_data.getDirectories ())
					{
						out.print ('\t');
						out.print (m_data.getValue (strDirectory, nNumThreads, strKey));
					}

					out.println ();
				}

				out.flush ();
				out.close ();
			}
			catch (FileNotFoundException e)
			{
			}
		}
	}

	public static void main (String[] args)
	{
		new ReadQsubResults (args).process ();
	}
}
